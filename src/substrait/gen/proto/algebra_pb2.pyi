"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
SPDX-License-Identifier: Apache-2.0"""
import builtins
import collections.abc
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
from .. import proto
import sys
import typing
if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _AggregationPhase:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _AggregationPhaseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AggregationPhase.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    AGGREGATION_PHASE_UNSPECIFIED: _AggregationPhase.ValueType
    'Implies `INTERMEDIATE_TO_RESULT`.'
    AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE: _AggregationPhase.ValueType
    'Specifies that the function should be run only up to the point of\n    generating an intermediate value, to be further aggregated later using\n    INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.\n    '
    AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE: _AggregationPhase.ValueType
    'Specifies that the inputs of the aggregate or window function are the\n    intermediate values of the function, and that the output should also be\n    an intermediate value, to be further aggregated later using\n    INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.\n    '
    AGGREGATION_PHASE_INITIAL_TO_RESULT: _AggregationPhase.ValueType
    'A complete invocation: the function should aggregate the given set of\n    inputs to yield a single return value. This style must be used for\n    aggregate or window functions that are not decomposable.\n    '
    AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT: _AggregationPhase.ValueType
    'Specifies that the inputs of the aggregate or window function are the\n    intermediate values of the function, generated previously using\n    INITIAL_TO_INTERMEDIATE and possibly INTERMEDIATE_TO_INTERMEDIATE calls.\n    This call should combine the intermediate values to yield the final\n    return value.\n    '

class AggregationPhase(_AggregationPhase, metaclass=_AggregationPhaseEnumTypeWrapper):
    """Describes which part of an aggregation or window function to perform within
    the context of distributed algorithms.
    """
AGGREGATION_PHASE_UNSPECIFIED: AggregationPhase.ValueType
'Implies `INTERMEDIATE_TO_RESULT`.'
AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE: AggregationPhase.ValueType
'Specifies that the function should be run only up to the point of\ngenerating an intermediate value, to be further aggregated later using\nINTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.\n'
AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE: AggregationPhase.ValueType
'Specifies that the inputs of the aggregate or window function are the\nintermediate values of the function, and that the output should also be\nan intermediate value, to be further aggregated later using\nINTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.\n'
AGGREGATION_PHASE_INITIAL_TO_RESULT: AggregationPhase.ValueType
'A complete invocation: the function should aggregate the given set of\ninputs to yield a single return value. This style must be used for\naggregate or window functions that are not decomposable.\n'
AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT: AggregationPhase.ValueType
'Specifies that the inputs of the aggregate or window function are the\nintermediate values of the function, generated previously using\nINITIAL_TO_INTERMEDIATE and possibly INTERMEDIATE_TO_INTERMEDIATE calls.\nThis call should combine the intermediate values to yield the final\nreturn value.\n'
global___AggregationPhase = AggregationPhase

@typing.final
class RelCommon(google.protobuf.message.Message):
    """Common fields for all relational operators"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Direct(google.protobuf.message.Message):
        """Direct indicates no change on presence and ordering of fields in the output"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        def __init__(self) -> None:
            ...

    @typing.final
    class Emit(google.protobuf.message.Message):
        """Remap which fields are output and in which order"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        OUTPUT_MAPPING_FIELD_NUMBER: builtins.int

        @property
        def output_mapping(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            ...

        def __init__(self, *, output_mapping: collections.abc.Iterable[builtins.int] | None=...) -> None:
            ...

        def ClearField(self, field_name: typing.Literal['output_mapping', b'output_mapping']) -> None:
            ...

    @typing.final
    class Hint(google.protobuf.message.Message):
        """Changes to the operation that can influence efficiency/performance but
        should not impact correctness.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _ComputationType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _ComputationTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RelCommon.Hint._ComputationType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            COMPUTATION_TYPE_UNSPECIFIED: RelCommon.Hint._ComputationType.ValueType
            COMPUTATION_TYPE_HASHTABLE: RelCommon.Hint._ComputationType.ValueType
            COMPUTATION_TYPE_BLOOM_FILTER: RelCommon.Hint._ComputationType.ValueType
            COMPUTATION_TYPE_UNKNOWN: RelCommon.Hint._ComputationType.ValueType

        class ComputationType(_ComputationType, metaclass=_ComputationTypeEnumTypeWrapper):
            ...
        COMPUTATION_TYPE_UNSPECIFIED: RelCommon.Hint.ComputationType.ValueType
        COMPUTATION_TYPE_HASHTABLE: RelCommon.Hint.ComputationType.ValueType
        COMPUTATION_TYPE_BLOOM_FILTER: RelCommon.Hint.ComputationType.ValueType
        COMPUTATION_TYPE_UNKNOWN: RelCommon.Hint.ComputationType.ValueType

        @typing.final
        class Stats(google.protobuf.message.Message):
            """The statistics related to a hint (physical properties of records)"""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            ROW_COUNT_FIELD_NUMBER: builtins.int
            RECORD_SIZE_FIELD_NUMBER: builtins.int
            ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
            row_count: builtins.float
            record_size: builtins.float

            @property
            def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
                ...

            def __init__(self, *, row_count: builtins.float=..., record_size: builtins.float=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'record_size', b'record_size', 'row_count', b'row_count']) -> None:
                ...

        @typing.final
        class RuntimeConstraint(google.protobuf.message.Message):
            """TODO: nodes, cpu threads/%, memory, iops, etc."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

            @property
            def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
                ...

            def __init__(self, *, advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension']) -> None:
                ...

        @typing.final
        class SavedComputation(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            COMPUTATION_ID_FIELD_NUMBER: builtins.int
            TYPE_FIELD_NUMBER: builtins.int
            computation_id: builtins.int
            'The value corresponds to a plan unique number for that datastructure.  Any particular\n            computation may be saved only once but it may be loaded multiple times.\n            '
            type: global___RelCommon.Hint.ComputationType.ValueType
            'The type of this computation.  While a plan may use COMPUTATION_TYPE_UNKNOWN for all\n            of its types it is recommended to use a more specific type so that the optimization\n            is more portable.  The consumer should be able to decide if an unknown type here\n            matches the same unknown type at a different plan and ignore the optimization if they\n            are mismatched.\n            '

            def __init__(self, *, computation_id: builtins.int=..., type: global___RelCommon.Hint.ComputationType.ValueType=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['computation_id', b'computation_id', 'type', b'type']) -> None:
                ...

        @typing.final
        class LoadedComputation(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            COMPUTATION_ID_REFERENCE_FIELD_NUMBER: builtins.int
            TYPE_FIELD_NUMBER: builtins.int
            computation_id_reference: builtins.int
            'The value corresponds to a plan unique number for that datastructure.  Any particular\n            computation may be saved only once but it may be loaded multiple times.\n            '
            type: global___RelCommon.Hint.ComputationType.ValueType
            'The type of this computation.  While a plan may use COMPUTATION_TYPE_UNKNOWN for all\n            of its types it is recommended to use a more specific type so that the optimization\n            is more portable.  The consumer should be able to decide if an unknown type here\n            matches the same unknown type at a different plan and ignore the optimization if they\n            are mismatched.\n            '

            def __init__(self, *, computation_id_reference: builtins.int=..., type: global___RelCommon.Hint.ComputationType.ValueType=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['computation_id_reference', b'computation_id_reference', 'type', b'type']) -> None:
                ...
        STATS_FIELD_NUMBER: builtins.int
        CONSTRAINT_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        OUTPUT_NAMES_FIELD_NUMBER: builtins.int
        ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
        SAVED_COMPUTATIONS_FIELD_NUMBER: builtins.int
        LOADED_COMPUTATIONS_FIELD_NUMBER: builtins.int
        alias: builtins.str
        "Name (alias) for this relation. Can be used for e.g. qualifying the relation (see e.g.\n        Spark's SubqueryAlias), or debugging.\n        "

        @property
        def stats(self) -> global___RelCommon.Hint.Stats:
            ...

        @property
        def constraint(self) -> global___RelCommon.Hint.RuntimeConstraint:
            ...

        @property
        def output_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Assigns alternative output field names for any relation.  Equivalent to the names field
            in RelRoot but applies to the output of the relation this RelCommon is attached to.
            """

        @property
        def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
            ...

        @property
        def saved_computations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RelCommon.Hint.SavedComputation]:
            """Save or load a system-specific computation for use in optimizing a remote operation.
            The anchor refers to the source/destination of the computation.  The computation type
            and number refer to the current relation.
            """

        @property
        def loaded_computations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RelCommon.Hint.LoadedComputation]:
            ...

        def __init__(self, *, stats: global___RelCommon.Hint.Stats | None=..., constraint: global___RelCommon.Hint.RuntimeConstraint | None=..., alias: builtins.str=..., output_names: collections.abc.Iterable[builtins.str] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=..., saved_computations: collections.abc.Iterable[global___RelCommon.Hint.SavedComputation] | None=..., loaded_computations: collections.abc.Iterable[global___RelCommon.Hint.LoadedComputation] | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'constraint', b'constraint', 'stats', b'stats']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'alias', b'alias', 'constraint', b'constraint', 'loaded_computations', b'loaded_computations', 'output_names', b'output_names', 'saved_computations', b'saved_computations', 'stats', b'stats']) -> None:
            ...
    DIRECT_FIELD_NUMBER: builtins.int
    EMIT_FIELD_NUMBER: builtins.int
    HINT_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def direct(self) -> global___RelCommon.Direct:
        """The underlying relation is output as is (no reordering or projection of columns)"""

    @property
    def emit(self) -> global___RelCommon.Emit:
        """Allows to control for order and inclusion of fields"""

    @property
    def hint(self) -> global___RelCommon.Hint:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, direct: global___RelCommon.Direct | None=..., emit: global___RelCommon.Emit | None=..., hint: global___RelCommon.Hint | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'direct', b'direct', 'emit', b'emit', 'emit_kind', b'emit_kind', 'hint', b'hint']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'direct', b'direct', 'emit', b'emit', 'emit_kind', b'emit_kind', 'hint', b'hint']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['emit_kind', b'emit_kind']) -> typing.Literal['direct', 'emit'] | None:
        ...
global___RelCommon = RelCommon

@typing.final
class ReadRel(google.protobuf.message.Message):
    """The scan operator of base data (physical or virtual), including filtering and projection."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class NamedTable(google.protobuf.message.Message):
        """A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).
        This assumes shared catalog between systems exchanging a message.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAMES_FIELD_NUMBER: builtins.int
        ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

        @property
        def names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            ...

        @property
        def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
            ...

        def __init__(self, *, names: collections.abc.Iterable[builtins.str] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'names', b'names']) -> None:
            ...

    @typing.final
    class IcebergTable(google.protobuf.message.Message):
        """Read an Iceberg Table"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class MetadataFileRead(google.protobuf.message.Message):
            """Read an Iceberg table using a metadata file. Implicit assumption: required credentials are already known by plan consumer."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            METADATA_URI_FIELD_NUMBER: builtins.int
            SNAPSHOT_ID_FIELD_NUMBER: builtins.int
            SNAPSHOT_TIMESTAMP_FIELD_NUMBER: builtins.int
            metadata_uri: builtins.str
            'the specific uri of a metadata file (e.g. s3://mybucket/mytable/<ver>-<uuid>.metadata.json)'
            snapshot_id: builtins.str
            'the snapshot id to read.'
            snapshot_timestamp: builtins.int
            'the timestamp that should be used to select the snapshot (Time passed in microseconds since 1970-01-01 00:00:00.000000 in UTC)'

            def __init__(self, *, metadata_uri: builtins.str=..., snapshot_id: builtins.str=..., snapshot_timestamp: builtins.int=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['snapshot', b'snapshot', 'snapshot_id', b'snapshot_id', 'snapshot_timestamp', b'snapshot_timestamp']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['metadata_uri', b'metadata_uri', 'snapshot', b'snapshot', 'snapshot_id', b'snapshot_id', 'snapshot_timestamp', b'snapshot_timestamp']) -> None:
                ...

            def WhichOneof(self, oneof_group: typing.Literal['snapshot', b'snapshot']) -> typing.Literal['snapshot_id', 'snapshot_timestamp'] | None:
                ...
        DIRECT_FIELD_NUMBER: builtins.int

        @property
        def direct(self) -> global___ReadRel.IcebergTable.MetadataFileRead:
            """future: add catalog table types (e.g. rest api, latest metadata in path, etc)"""

        def __init__(self, *, direct: global___ReadRel.IcebergTable.MetadataFileRead | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['direct', b'direct', 'table_type', b'table_type']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['direct', b'direct', 'table_type', b'table_type']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['table_type', b'table_type']) -> typing.Literal['direct'] | None:
            ...

    @typing.final
    class VirtualTable(google.protobuf.message.Message):
        """A table composed of expressions."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        VALUES_FIELD_NUMBER: builtins.int
        EXPRESSIONS_FIELD_NUMBER: builtins.int

        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.Literal.Struct]:
            ...

        @property
        def expressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.Nested.Struct]:
            ...

        def __init__(self, *, values: collections.abc.Iterable[global___Expression.Literal.Struct] | None=..., expressions: collections.abc.Iterable[global___Expression.Nested.Struct] | None=...) -> None:
            ...

        def ClearField(self, field_name: typing.Literal['expressions', b'expressions', 'values', b'values']) -> None:
            ...

    @typing.final
    class ExtensionTable(google.protobuf.message.Message):
        """A stub type that can be used to extend/introduce new table types outside
        the specification.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        DETAIL_FIELD_NUMBER: builtins.int

        @property
        def detail(self) -> google.protobuf.any_pb2.Any:
            ...

        def __init__(self, *, detail: google.protobuf.any_pb2.Any | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['detail', b'detail']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['detail', b'detail']) -> None:
            ...

    @typing.final
    class LocalFiles(google.protobuf.message.Message):
        """Represents a list of files in input of a scan operation"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class FileOrFiles(google.protobuf.message.Message):
            """Many files consist of indivisible chunks (e.g. parquet row groups
            or CSV rows).  If a slice partially selects an indivisible chunk
            then the consumer should employ some rule to decide which slice to
            include the chunk in (e.g. include it in the slice that contains
            the midpoint of the chunk)
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            @typing.final
            class ParquetReadOptions(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor

                def __init__(self) -> None:
                    ...

            @typing.final
            class ArrowReadOptions(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor

                def __init__(self) -> None:
                    ...

            @typing.final
            class OrcReadOptions(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor

                def __init__(self) -> None:
                    ...

            @typing.final
            class DwrfReadOptions(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor

                def __init__(self) -> None:
                    ...

            @typing.final
            class DelimiterSeparatedTextReadOptions(google.protobuf.message.Message):
                """Delimiter separated files may be compressed.  The reader should
                autodetect this and decompress as needed.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                FIELD_DELIMITER_FIELD_NUMBER: builtins.int
                MAX_LINE_SIZE_FIELD_NUMBER: builtins.int
                QUOTE_FIELD_NUMBER: builtins.int
                HEADER_LINES_TO_SKIP_FIELD_NUMBER: builtins.int
                ESCAPE_FIELD_NUMBER: builtins.int
                VALUE_TREATED_AS_NULL_FIELD_NUMBER: builtins.int
                field_delimiter: builtins.str
                'The character(s) used to separate fields.  Common values are comma,\n                tab, and pipe.  Multiple characters are allowed.\n                '
                max_line_size: builtins.int
                'The maximum number of bytes to read from a single line.  If a line\n                exceeds this limit the resulting behavior is undefined.\n                '
                quote: builtins.str
                'The character(s) used to quote strings.  Common values are single\n                and double quotation marks.\n                '
                header_lines_to_skip: builtins.int
                'The number of lines to skip at the beginning of the file.'
                escape: builtins.str
                'The character used to escape characters in strings.  Backslash is\n                a common value.  Note that a double quote mark can also be used as an\n                escape character but the external quotes should be removed first.\n                '
                value_treated_as_null: builtins.str
                'If this value is encountered (including empty string), the resulting\n                value is null instead.  Leave unset to disable.  If this value is\n                provided, the effective schema of this file is comprised entirely of\n                nullable strings.  If not provided, the effective schema is instead\n                made up of non-nullable strings.\n                '

                def __init__(self, *, field_delimiter: builtins.str=..., max_line_size: builtins.int=..., quote: builtins.str=..., header_lines_to_skip: builtins.int=..., escape: builtins.str=..., value_treated_as_null: builtins.str | None=...) -> None:
                    ...

                def HasField(self, field_name: typing.Literal['_value_treated_as_null', b'_value_treated_as_null', 'value_treated_as_null', b'value_treated_as_null']) -> builtins.bool:
                    ...

                def ClearField(self, field_name: typing.Literal['_value_treated_as_null', b'_value_treated_as_null', 'escape', b'escape', 'field_delimiter', b'field_delimiter', 'header_lines_to_skip', b'header_lines_to_skip', 'max_line_size', b'max_line_size', 'quote', b'quote', 'value_treated_as_null', b'value_treated_as_null']) -> None:
                    ...

                def WhichOneof(self, oneof_group: typing.Literal['_value_treated_as_null', b'_value_treated_as_null']) -> typing.Literal['value_treated_as_null'] | None:
                    ...
            URI_PATH_FIELD_NUMBER: builtins.int
            URI_PATH_GLOB_FIELD_NUMBER: builtins.int
            URI_FILE_FIELD_NUMBER: builtins.int
            URI_FOLDER_FIELD_NUMBER: builtins.int
            PARTITION_INDEX_FIELD_NUMBER: builtins.int
            START_FIELD_NUMBER: builtins.int
            LENGTH_FIELD_NUMBER: builtins.int
            PARQUET_FIELD_NUMBER: builtins.int
            ARROW_FIELD_NUMBER: builtins.int
            ORC_FIELD_NUMBER: builtins.int
            EXTENSION_FIELD_NUMBER: builtins.int
            DWRF_FIELD_NUMBER: builtins.int
            TEXT_FIELD_NUMBER: builtins.int
            uri_path: builtins.str
            'A URI that can refer to either a single folder or a single file'
            uri_path_glob: builtins.str
            'A URI where the path portion is a glob expression that can\n            identify zero or more paths.\n            Consumers should support the POSIX syntax.  The recursive\n            globstar (**) may not be supported.\n            '
            uri_file: builtins.str
            'A URI that refers to a single file'
            uri_folder: builtins.str
            'A URI that refers to a single folder'
            partition_index: builtins.int
            'The index of the partition this item belongs to'
            start: builtins.int
            'The start position in byte to read from this item'
            length: builtins.int
            'The length in byte to read from this item'

            @property
            def parquet(self) -> global___ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions:
                ...

            @property
            def arrow(self) -> global___ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions:
                ...

            @property
            def orc(self) -> global___ReadRel.LocalFiles.FileOrFiles.OrcReadOptions:
                ...

            @property
            def extension(self) -> google.protobuf.any_pb2.Any:
                ...

            @property
            def dwrf(self) -> global___ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions:
                ...

            @property
            def text(self) -> global___ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions:
                ...

            def __init__(self, *, uri_path: builtins.str=..., uri_path_glob: builtins.str=..., uri_file: builtins.str=..., uri_folder: builtins.str=..., partition_index: builtins.int=..., start: builtins.int=..., length: builtins.int=..., parquet: global___ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions | None=..., arrow: global___ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions | None=..., orc: global___ReadRel.LocalFiles.FileOrFiles.OrcReadOptions | None=..., extension: google.protobuf.any_pb2.Any | None=..., dwrf: global___ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions | None=..., text: global___ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['arrow', b'arrow', 'dwrf', b'dwrf', 'extension', b'extension', 'file_format', b'file_format', 'orc', b'orc', 'parquet', b'parquet', 'path_type', b'path_type', 'text', b'text', 'uri_file', b'uri_file', 'uri_folder', b'uri_folder', 'uri_path', b'uri_path', 'uri_path_glob', b'uri_path_glob']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['arrow', b'arrow', 'dwrf', b'dwrf', 'extension', b'extension', 'file_format', b'file_format', 'length', b'length', 'orc', b'orc', 'parquet', b'parquet', 'partition_index', b'partition_index', 'path_type', b'path_type', 'start', b'start', 'text', b'text', 'uri_file', b'uri_file', 'uri_folder', b'uri_folder', 'uri_path', b'uri_path', 'uri_path_glob', b'uri_path_glob']) -> None:
                ...

            @typing.overload
            def WhichOneof(self, oneof_group: typing.Literal['file_format', b'file_format']) -> typing.Literal['parquet', 'arrow', 'orc', 'extension', 'dwrf', 'text'] | None:
                ...

            @typing.overload
            def WhichOneof(self, oneof_group: typing.Literal['path_type', b'path_type']) -> typing.Literal['uri_path', 'uri_path_glob', 'uri_file', 'uri_folder'] | None:
                ...
        ITEMS_FIELD_NUMBER: builtins.int
        ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

        @property
        def items(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ReadRel.LocalFiles.FileOrFiles]:
            ...

        @property
        def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
            ...

        def __init__(self, *, items: collections.abc.Iterable[global___ReadRel.LocalFiles.FileOrFiles] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'items', b'items']) -> None:
            ...
    COMMON_FIELD_NUMBER: builtins.int
    BASE_SCHEMA_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    BEST_EFFORT_FILTER_FIELD_NUMBER: builtins.int
    PROJECTION_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    VIRTUAL_TABLE_FIELD_NUMBER: builtins.int
    LOCAL_FILES_FIELD_NUMBER: builtins.int
    NAMED_TABLE_FIELD_NUMBER: builtins.int
    EXTENSION_TABLE_FIELD_NUMBER: builtins.int
    ICEBERG_TABLE_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def base_schema(self) -> proto.type_pb2.NamedStruct:
        ...

    @property
    def filter(self) -> global___Expression:
        ...

    @property
    def best_effort_filter(self) -> global___Expression:
        ...

    @property
    def projection(self) -> global___Expression.MaskExpression:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    @property
    def virtual_table(self) -> global___ReadRel.VirtualTable:
        ...

    @property
    def local_files(self) -> global___ReadRel.LocalFiles:
        ...

    @property
    def named_table(self) -> global___ReadRel.NamedTable:
        ...

    @property
    def extension_table(self) -> global___ReadRel.ExtensionTable:
        ...

    @property
    def iceberg_table(self) -> global___ReadRel.IcebergTable:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., base_schema: proto.type_pb2.NamedStruct | None=..., filter: global___Expression | None=..., best_effort_filter: global___Expression | None=..., projection: global___Expression.MaskExpression | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=..., virtual_table: global___ReadRel.VirtualTable | None=..., local_files: global___ReadRel.LocalFiles | None=..., named_table: global___ReadRel.NamedTable | None=..., extension_table: global___ReadRel.ExtensionTable | None=..., iceberg_table: global___ReadRel.IcebergTable | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'base_schema', b'base_schema', 'best_effort_filter', b'best_effort_filter', 'common', b'common', 'extension_table', b'extension_table', 'filter', b'filter', 'iceberg_table', b'iceberg_table', 'local_files', b'local_files', 'named_table', b'named_table', 'projection', b'projection', 'read_type', b'read_type', 'virtual_table', b'virtual_table']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'base_schema', b'base_schema', 'best_effort_filter', b'best_effort_filter', 'common', b'common', 'extension_table', b'extension_table', 'filter', b'filter', 'iceberg_table', b'iceberg_table', 'local_files', b'local_files', 'named_table', b'named_table', 'projection', b'projection', 'read_type', b'read_type', 'virtual_table', b'virtual_table']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['read_type', b'read_type']) -> typing.Literal['virtual_table', 'local_files', 'named_table', 'extension_table', 'iceberg_table'] | None:
        ...
global___ReadRel = ReadRel

@typing.final
class ProjectRel(google.protobuf.message.Message):
    """This operator allows to represent calculated expressions of fields (e.g., a+b). Direct/Emit are used to represent classical relational projections"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    EXPRESSIONS_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def expressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., expressions: collections.abc.Iterable[global___Expression] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'expressions', b'expressions', 'input', b'input']) -> None:
        ...
global___ProjectRel = ProjectRel

@typing.final
class JoinRel(google.protobuf.message.Message):
    """The binary JOIN relational operator left-join-right, including various join types, a join condition and post_join_filter expression"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _JoinType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _JoinTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[JoinRel._JoinType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        JOIN_TYPE_UNSPECIFIED: JoinRel._JoinType.ValueType
        JOIN_TYPE_INNER: JoinRel._JoinType.ValueType
        JOIN_TYPE_OUTER: JoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT: JoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT: JoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SEMI: JoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_ANTI: JoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SINGLE: JoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SEMI: JoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_ANTI: JoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SINGLE: JoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_MARK: JoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_MARK: JoinRel._JoinType.ValueType

    class JoinType(_JoinType, metaclass=_JoinTypeEnumTypeWrapper):
        ...
    JOIN_TYPE_UNSPECIFIED: JoinRel.JoinType.ValueType
    JOIN_TYPE_INNER: JoinRel.JoinType.ValueType
    JOIN_TYPE_OUTER: JoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT: JoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT: JoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SEMI: JoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_ANTI: JoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SINGLE: JoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SEMI: JoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_ANTI: JoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SINGLE: JoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_MARK: JoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_MARK: JoinRel.JoinType.ValueType
    COMMON_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    EXPRESSION_FIELD_NUMBER: builtins.int
    POST_JOIN_FILTER_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    type: global___JoinRel.JoinType.ValueType

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def left(self) -> global___Rel:
        ...

    @property
    def right(self) -> global___Rel:
        ...

    @property
    def expression(self) -> global___Expression:
        ...

    @property
    def post_join_filter(self) -> global___Expression:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., left: global___Rel | None=..., right: global___Rel | None=..., expression: global___Expression | None=..., post_join_filter: global___Expression | None=..., type: global___JoinRel.JoinType.ValueType=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'expression', b'expression', 'left', b'left', 'post_join_filter', b'post_join_filter', 'right', b'right']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'expression', b'expression', 'left', b'left', 'post_join_filter', b'post_join_filter', 'right', b'right', 'type', b'type']) -> None:
        ...
global___JoinRel = JoinRel

@typing.final
class CrossRel(google.protobuf.message.Message):
    """Cartesian product relational operator of two tables (left and right)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def left(self) -> global___Rel:
        ...

    @property
    def right(self) -> global___Rel:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., left: global___Rel | None=..., right: global___Rel | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'left', b'left', 'right', b'right']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'left', b'left', 'right', b'right']) -> None:
        ...
global___CrossRel = CrossRel

@typing.final
class FetchRel(google.protobuf.message.Message):
    """The relational operator representing LIMIT/OFFSET or TOP type semantics."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    OFFSET_EXPR_FIELD_NUMBER: builtins.int
    COUNT_FIELD_NUMBER: builtins.int
    COUNT_EXPR_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    offset: builtins.int
    'the offset expressed in number of records\n    Deprecated: use `offset_expr` instead\n    '
    count: builtins.int
    'the amount of records to return\n    use -1 to signal that ALL records should be returned\n    Deprecated: use `count_expr` instead\n    '

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def offset_expr(self) -> global___Expression:
        """Expression evaluated into a non-negative integer specifying the number
        of records to skip. An expression evaluating to null is treated as 0.
        Evaluating to a negative integer should result in an error.
        Recommended type for offset is int64.
        """

    @property
    def count_expr(self) -> global___Expression:
        """Expression evaluated into a non-negative integer specifying the number
        of records to return. An expression evaluating to null signals that ALL
        records should be returned.
        Evaluating to a negative integer should result in an error.
        Recommended type for count is int64.
        """

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., offset: builtins.int=..., offset_expr: global___Expression | None=..., count: builtins.int=..., count_expr: global___Expression | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'count', b'count', 'count_expr', b'count_expr', 'count_mode', b'count_mode', 'input', b'input', 'offset', b'offset', 'offset_expr', b'offset_expr', 'offset_mode', b'offset_mode']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'count', b'count', 'count_expr', b'count_expr', 'count_mode', b'count_mode', 'input', b'input', 'offset', b'offset', 'offset_expr', b'offset_expr', 'offset_mode', b'offset_mode']) -> None:
        ...

    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal['count_mode', b'count_mode']) -> typing.Literal['count', 'count_expr'] | None:
        ...

    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal['offset_mode', b'offset_mode']) -> typing.Literal['offset', 'offset_expr'] | None:
        ...
global___FetchRel = FetchRel

@typing.final
class AggregateRel(google.protobuf.message.Message):
    """The relational operator representing a GROUP BY Aggregate"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Grouping(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        GROUPING_EXPRESSIONS_FIELD_NUMBER: builtins.int
        EXPRESSION_REFERENCES_FIELD_NUMBER: builtins.int

        @property
        def grouping_expressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """Deprecated in favor of `expression_references` below."""

        @property
        def expression_references(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """A list of zero or more references to grouping expressions, i.e., indices
            into the `grouping_expression` list.
            """

        def __init__(self, *, grouping_expressions: collections.abc.Iterable[global___Expression] | None=..., expression_references: collections.abc.Iterable[builtins.int] | None=...) -> None:
            ...

        def ClearField(self, field_name: typing.Literal['expression_references', b'expression_references', 'grouping_expressions', b'grouping_expressions']) -> None:
            ...

    @typing.final
    class Measure(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        MEASURE_FIELD_NUMBER: builtins.int
        FILTER_FIELD_NUMBER: builtins.int

        @property
        def measure(self) -> global___AggregateFunction:
            ...

        @property
        def filter(self) -> global___Expression:
            """An optional boolean expression that acts to filter which records are
            included in the measure. True means include this record for calculation
            within the measure.
            Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization
            """

        def __init__(self, *, measure: global___AggregateFunction | None=..., filter: global___Expression | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['filter', b'filter', 'measure', b'measure']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['filter', b'filter', 'measure', b'measure']) -> None:
            ...
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    GROUPINGS_FIELD_NUMBER: builtins.int
    MEASURES_FIELD_NUMBER: builtins.int
    GROUPING_EXPRESSIONS_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        """Input of the aggregation"""

    @property
    def groupings(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregateRel.Grouping]:
        """A list of zero or more grouping sets that the aggregation measures should
        be calculated for. There must be at least one grouping set if there are no
        measures (but it can be the empty grouping set).
        """

    @property
    def measures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregateRel.Measure]:
        """A list of one or more aggregate expressions along with an optional filter.
        Required if there are no groupings.
        """

    @property
    def grouping_expressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        """A list of zero or more grouping expressions that grouping sets (i.e.,
        `Grouping` messages in the `groupings` field) can reference. Each
        expression in this list must be referred to by at least one
        `Grouping.expression_references`.
        """

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., groupings: collections.abc.Iterable[global___AggregateRel.Grouping] | None=..., measures: collections.abc.Iterable[global___AggregateRel.Measure] | None=..., grouping_expressions: collections.abc.Iterable[global___Expression] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'grouping_expressions', b'grouping_expressions', 'groupings', b'groupings', 'input', b'input', 'measures', b'measures']) -> None:
        ...
global___AggregateRel = AggregateRel

@typing.final
class ConsistentPartitionWindowRel(google.protobuf.message.Message):
    """ConsistentPartitionWindowRel provides the ability to perform calculations across sets of rows
    that are related to the current query row. It can be used to execute window functions where
    all the windows share the same partitioning and ordering.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class WindowRelFunction(google.protobuf.message.Message):
        """This message mirrors the `WindowFunction` message but removes the fields defining the partition,
        sorts, and bounds, since those must be consistent across the various functions in this rel.  Refer
        to the `WindowFunction` message for a description of these fields.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        FUNCTION_REFERENCE_FIELD_NUMBER: builtins.int
        ARGUMENTS_FIELD_NUMBER: builtins.int
        OPTIONS_FIELD_NUMBER: builtins.int
        OUTPUT_TYPE_FIELD_NUMBER: builtins.int
        PHASE_FIELD_NUMBER: builtins.int
        INVOCATION_FIELD_NUMBER: builtins.int
        LOWER_BOUND_FIELD_NUMBER: builtins.int
        UPPER_BOUND_FIELD_NUMBER: builtins.int
        BOUNDS_TYPE_FIELD_NUMBER: builtins.int
        function_reference: builtins.int
        phase: global___AggregationPhase.ValueType
        invocation: global___AggregateFunction.AggregationInvocation.ValueType
        bounds_type: global___Expression.WindowFunction.BoundsType.ValueType

        @property
        def arguments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionArgument]:
            ...

        @property
        def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionOption]:
            ...

        @property
        def output_type(self) -> proto.type_pb2.Type:
            ...

        @property
        def lower_bound(self) -> global___Expression.WindowFunction.Bound:
            ...

        @property
        def upper_bound(self) -> global___Expression.WindowFunction.Bound:
            ...

        def __init__(self, *, function_reference: builtins.int=..., arguments: collections.abc.Iterable[global___FunctionArgument] | None=..., options: collections.abc.Iterable[global___FunctionOption] | None=..., output_type: proto.type_pb2.Type | None=..., phase: global___AggregationPhase.ValueType=..., invocation: global___AggregateFunction.AggregationInvocation.ValueType=..., lower_bound: global___Expression.WindowFunction.Bound | None=..., upper_bound: global___Expression.WindowFunction.Bound | None=..., bounds_type: global___Expression.WindowFunction.BoundsType.ValueType=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['lower_bound', b'lower_bound', 'output_type', b'output_type', 'upper_bound', b'upper_bound']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['arguments', b'arguments', 'bounds_type', b'bounds_type', 'function_reference', b'function_reference', 'invocation', b'invocation', 'lower_bound', b'lower_bound', 'options', b'options', 'output_type', b'output_type', 'phase', b'phase', 'upper_bound', b'upper_bound']) -> None:
            ...
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    WINDOW_FUNCTIONS_FIELD_NUMBER: builtins.int
    PARTITION_EXPRESSIONS_FIELD_NUMBER: builtins.int
    SORTS_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def window_functions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConsistentPartitionWindowRel.WindowRelFunction]:
        ...

    @property
    def partition_expressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        ...

    @property
    def sorts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SortField]:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., window_functions: collections.abc.Iterable[global___ConsistentPartitionWindowRel.WindowRelFunction] | None=..., partition_expressions: collections.abc.Iterable[global___Expression] | None=..., sorts: collections.abc.Iterable[global___SortField] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'input', b'input', 'partition_expressions', b'partition_expressions', 'sorts', b'sorts', 'window_functions', b'window_functions']) -> None:
        ...
global___ConsistentPartitionWindowRel = ConsistentPartitionWindowRel

@typing.final
class SortRel(google.protobuf.message.Message):
    """The ORDERY BY (or sorting) relational operator. Beside describing a base relation, it includes a list of fields to sort on"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    SORTS_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def sorts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SortField]:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., sorts: collections.abc.Iterable[global___SortField] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'input', b'input', 'sorts', b'sorts']) -> None:
        ...
global___SortRel = SortRel

@typing.final
class FilterRel(google.protobuf.message.Message):
    """The relational operator capturing simple FILTERs (as in the WHERE clause of SQL)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def condition(self) -> global___Expression:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., condition: global___Expression | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'condition', b'condition', 'input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'condition', b'condition', 'input', b'input']) -> None:
        ...
global___FilterRel = FilterRel

@typing.final
class SetRel(google.protobuf.message.Message):
    """The relational set operators (intersection/union/etc..)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SetOp:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SetOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SetRel._SetOp.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SET_OP_UNSPECIFIED: SetRel._SetOp.ValueType
        SET_OP_MINUS_PRIMARY: SetRel._SetOp.ValueType
        SET_OP_MINUS_PRIMARY_ALL: SetRel._SetOp.ValueType
        SET_OP_MINUS_MULTISET: SetRel._SetOp.ValueType
        SET_OP_INTERSECTION_PRIMARY: SetRel._SetOp.ValueType
        SET_OP_INTERSECTION_MULTISET: SetRel._SetOp.ValueType
        SET_OP_INTERSECTION_MULTISET_ALL: SetRel._SetOp.ValueType
        SET_OP_UNION_DISTINCT: SetRel._SetOp.ValueType
        SET_OP_UNION_ALL: SetRel._SetOp.ValueType

    class SetOp(_SetOp, metaclass=_SetOpEnumTypeWrapper):
        ...
    SET_OP_UNSPECIFIED: SetRel.SetOp.ValueType
    SET_OP_MINUS_PRIMARY: SetRel.SetOp.ValueType
    SET_OP_MINUS_PRIMARY_ALL: SetRel.SetOp.ValueType
    SET_OP_MINUS_MULTISET: SetRel.SetOp.ValueType
    SET_OP_INTERSECTION_PRIMARY: SetRel.SetOp.ValueType
    SET_OP_INTERSECTION_MULTISET: SetRel.SetOp.ValueType
    SET_OP_INTERSECTION_MULTISET_ALL: SetRel.SetOp.ValueType
    SET_OP_UNION_DISTINCT: SetRel.SetOp.ValueType
    SET_OP_UNION_ALL: SetRel.SetOp.ValueType
    COMMON_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    OP_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    op: global___SetRel.SetOp.ValueType

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def inputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Rel]:
        """The first input is the primary input, the remaining are secondary
        inputs.  There must be at least two inputs.
        """

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., inputs: collections.abc.Iterable[global___Rel] | None=..., op: global___SetRel.SetOp.ValueType=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'inputs', b'inputs', 'op', b'op']) -> None:
        ...
global___SetRel = SetRel

@typing.final
class ExtensionSingleRel(google.protobuf.message.Message):
    """Stub to support extension with a single input"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    DETAIL_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def detail(self) -> google.protobuf.any_pb2.Any:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., detail: google.protobuf.any_pb2.Any | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['common', b'common', 'detail', b'detail', 'input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['common', b'common', 'detail', b'detail', 'input', b'input']) -> None:
        ...
global___ExtensionSingleRel = ExtensionSingleRel

@typing.final
class ExtensionLeafRel(google.protobuf.message.Message):
    """Stub to support extension with a zero inputs"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    DETAIL_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def detail(self) -> google.protobuf.any_pb2.Any:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., detail: google.protobuf.any_pb2.Any | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['common', b'common', 'detail', b'detail']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['common', b'common', 'detail', b'detail']) -> None:
        ...
global___ExtensionLeafRel = ExtensionLeafRel

@typing.final
class ExtensionMultiRel(google.protobuf.message.Message):
    """Stub to support extension with multiple inputs"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMON_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    DETAIL_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def inputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Rel]:
        ...

    @property
    def detail(self) -> google.protobuf.any_pb2.Any:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., inputs: collections.abc.Iterable[global___Rel] | None=..., detail: google.protobuf.any_pb2.Any | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['common', b'common', 'detail', b'detail']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['common', b'common', 'detail', b'detail', 'inputs', b'inputs']) -> None:
        ...
global___ExtensionMultiRel = ExtensionMultiRel

@typing.final
class ExchangeRel(google.protobuf.message.Message):
    """A redistribution operation"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ScatterFields(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        FIELDS_FIELD_NUMBER: builtins.int

        @property
        def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.FieldReference]:
            ...

        def __init__(self, *, fields: collections.abc.Iterable[global___Expression.FieldReference] | None=...) -> None:
            ...

        def ClearField(self, field_name: typing.Literal['fields', b'fields']) -> None:
            ...

    @typing.final
    class SingleBucketExpression(google.protobuf.message.Message):
        """Returns a single bucket number per record."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        EXPRESSION_FIELD_NUMBER: builtins.int

        @property
        def expression(self) -> global___Expression:
            ...

        def __init__(self, *, expression: global___Expression | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['expression', b'expression']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['expression', b'expression']) -> None:
            ...

    @typing.final
    class MultiBucketExpression(google.protobuf.message.Message):
        """Returns zero or more bucket numbers per record"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        EXPRESSION_FIELD_NUMBER: builtins.int
        CONSTRAINED_TO_COUNT_FIELD_NUMBER: builtins.int
        constrained_to_count: builtins.bool

        @property
        def expression(self) -> global___Expression:
            ...

        def __init__(self, *, expression: global___Expression | None=..., constrained_to_count: builtins.bool=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['expression', b'expression']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['constrained_to_count', b'constrained_to_count', 'expression', b'expression']) -> None:
            ...

    @typing.final
    class Broadcast(google.protobuf.message.Message):
        """Send all data to every target."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        def __init__(self) -> None:
            ...

    @typing.final
    class RoundRobin(google.protobuf.message.Message):
        """Route approximately"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        EXACT_FIELD_NUMBER: builtins.int
        exact: builtins.bool
        'whether the round robin behavior is required to exact (per record) or\n        approximate. Defaults to approximate.\n        '

        def __init__(self, *, exact: builtins.bool=...) -> None:
            ...

        def ClearField(self, field_name: typing.Literal['exact', b'exact']) -> None:
            ...

    @typing.final
    class ExchangeTarget(google.protobuf.message.Message):
        """The message to describe partition targets of an exchange"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        PARTITION_ID_FIELD_NUMBER: builtins.int
        URI_FIELD_NUMBER: builtins.int
        EXTENDED_FIELD_NUMBER: builtins.int
        uri: builtins.str

        @property
        def partition_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """Describes the partition id(s) to send. If this is empty, all data is sent
            to this target.
            """

        @property
        def extended(self) -> google.protobuf.any_pb2.Any:
            ...

        def __init__(self, *, partition_id: collections.abc.Iterable[builtins.int] | None=..., uri: builtins.str=..., extended: google.protobuf.any_pb2.Any | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['extended', b'extended', 'target_type', b'target_type', 'uri', b'uri']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['extended', b'extended', 'partition_id', b'partition_id', 'target_type', b'target_type', 'uri', b'uri']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['target_type', b'target_type']) -> typing.Literal['uri', 'extended'] | None:
            ...
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    PARTITION_COUNT_FIELD_NUMBER: builtins.int
    TARGETS_FIELD_NUMBER: builtins.int
    SCATTER_BY_FIELDS_FIELD_NUMBER: builtins.int
    SINGLE_TARGET_FIELD_NUMBER: builtins.int
    MULTI_TARGET_FIELD_NUMBER: builtins.int
    ROUND_ROBIN_FIELD_NUMBER: builtins.int
    BROADCAST_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    partition_count: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ExchangeRel.ExchangeTarget]:
        ...

    @property
    def scatter_by_fields(self) -> global___ExchangeRel.ScatterFields:
        ...

    @property
    def single_target(self) -> global___ExchangeRel.SingleBucketExpression:
        ...

    @property
    def multi_target(self) -> global___ExchangeRel.MultiBucketExpression:
        ...

    @property
    def round_robin(self) -> global___ExchangeRel.RoundRobin:
        ...

    @property
    def broadcast(self) -> global___ExchangeRel.Broadcast:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., partition_count: builtins.int=..., targets: collections.abc.Iterable[global___ExchangeRel.ExchangeTarget] | None=..., scatter_by_fields: global___ExchangeRel.ScatterFields | None=..., single_target: global___ExchangeRel.SingleBucketExpression | None=..., multi_target: global___ExchangeRel.MultiBucketExpression | None=..., round_robin: global___ExchangeRel.RoundRobin | None=..., broadcast: global___ExchangeRel.Broadcast | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'broadcast', b'broadcast', 'common', b'common', 'exchange_kind', b'exchange_kind', 'input', b'input', 'multi_target', b'multi_target', 'round_robin', b'round_robin', 'scatter_by_fields', b'scatter_by_fields', 'single_target', b'single_target']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'broadcast', b'broadcast', 'common', b'common', 'exchange_kind', b'exchange_kind', 'input', b'input', 'multi_target', b'multi_target', 'partition_count', b'partition_count', 'round_robin', b'round_robin', 'scatter_by_fields', b'scatter_by_fields', 'single_target', b'single_target', 'targets', b'targets']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['exchange_kind', b'exchange_kind']) -> typing.Literal['scatter_by_fields', 'single_target', 'multi_target', 'round_robin', 'broadcast'] | None:
        ...
global___ExchangeRel = ExchangeRel

@typing.final
class ExpandRel(google.protobuf.message.Message):
    """Duplicates records by emitting one or more rows per input row.  The number of rows emitted per
    input row is the same for all input rows.

    In addition to a field being emitted per input field an extra int64 field is emitted which
    contains a zero-indexed ordinal corresponding to the duplicate definition.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ExpandField(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        SWITCHING_FIELD_FIELD_NUMBER: builtins.int
        CONSISTENT_FIELD_FIELD_NUMBER: builtins.int

        @property
        def switching_field(self) -> global___ExpandRel.SwitchingField:
            """Field that switches output based on which duplicate is being output.  Every
            switching_field should contain the same number of duplicates (so that the output rows
            are of consistent size and type).  If there are not enough switching field definitions
            to match the other field definitions NULL will be returned to fill the extras.
            """

        @property
        def consistent_field(self) -> global___Expression:
            """Field that outputs the same value no matter which duplicate is being output.  Equivalent
            to a switching_field that lists the same expression multiple times.
            """

        def __init__(self, *, switching_field: global___ExpandRel.SwitchingField | None=..., consistent_field: global___Expression | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['consistent_field', b'consistent_field', 'field_type', b'field_type', 'switching_field', b'switching_field']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['consistent_field', b'consistent_field', 'field_type', b'field_type', 'switching_field', b'switching_field']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['field_type', b'field_type']) -> typing.Literal['switching_field', 'consistent_field'] | None:
            ...

    @typing.final
    class SwitchingField(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        DUPLICATES_FIELD_NUMBER: builtins.int

        @property
        def duplicates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """All duplicates must return the same type class but may differ in nullability.  The effective
            type of the output field will be nullable if any of the duplicate expressions are nullable.
            """

        def __init__(self, *, duplicates: collections.abc.Iterable[global___Expression] | None=...) -> None:
            ...

        def ClearField(self, field_name: typing.Literal['duplicates', b'duplicates']) -> None:
            ...
    COMMON_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    FIELDS_FIELD_NUMBER: builtins.int

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def input(self) -> global___Rel:
        ...

    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ExpandRel.ExpandField]:
        """There should be one definition here for each input field.  Any fields beyond the provided
        definitions will be emitted as is (as if a consistent_field record with an identity
        expression was provided).
        """

    def __init__(self, *, common: global___RelCommon | None=..., input: global___Rel | None=..., fields: collections.abc.Iterable[global___ExpandRel.ExpandField] | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['common', b'common', 'input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['common', b'common', 'fields', b'fields', 'input', b'input']) -> None:
        ...
global___ExpandRel = ExpandRel

@typing.final
class RelRoot(google.protobuf.message.Message):
    """A relation with output field names.

    This is for use at the root of a `Rel` tree.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    INPUT_FIELD_NUMBER: builtins.int
    NAMES_FIELD_NUMBER: builtins.int

    @property
    def input(self) -> global___Rel:
        """A relation"""

    @property
    def names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Field names in depth-first order"""

    def __init__(self, *, input: global___Rel | None=..., names: collections.abc.Iterable[builtins.str] | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['input', b'input']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['input', b'input', 'names', b'names']) -> None:
        ...
global___RelRoot = RelRoot

@typing.final
class Rel(google.protobuf.message.Message):
    """A relation (used internally in a plan)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    READ_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    FETCH_FIELD_NUMBER: builtins.int
    AGGREGATE_FIELD_NUMBER: builtins.int
    SORT_FIELD_NUMBER: builtins.int
    JOIN_FIELD_NUMBER: builtins.int
    PROJECT_FIELD_NUMBER: builtins.int
    SET_FIELD_NUMBER: builtins.int
    EXTENSION_SINGLE_FIELD_NUMBER: builtins.int
    EXTENSION_MULTI_FIELD_NUMBER: builtins.int
    EXTENSION_LEAF_FIELD_NUMBER: builtins.int
    CROSS_FIELD_NUMBER: builtins.int
    REFERENCE_FIELD_NUMBER: builtins.int
    WRITE_FIELD_NUMBER: builtins.int
    DDL_FIELD_NUMBER: builtins.int
    UPDATE_FIELD_NUMBER: builtins.int
    HASH_JOIN_FIELD_NUMBER: builtins.int
    MERGE_JOIN_FIELD_NUMBER: builtins.int
    NESTED_LOOP_JOIN_FIELD_NUMBER: builtins.int
    WINDOW_FIELD_NUMBER: builtins.int
    EXCHANGE_FIELD_NUMBER: builtins.int
    EXPAND_FIELD_NUMBER: builtins.int

    @property
    def read(self) -> global___ReadRel:
        ...

    @property
    def filter(self) -> global___FilterRel:
        ...

    @property
    def fetch(self) -> global___FetchRel:
        ...

    @property
    def aggregate(self) -> global___AggregateRel:
        ...

    @property
    def sort(self) -> global___SortRel:
        ...

    @property
    def join(self) -> global___JoinRel:
        ...

    @property
    def project(self) -> global___ProjectRel:
        ...

    @property
    def set(self) -> global___SetRel:
        ...

    @property
    def extension_single(self) -> global___ExtensionSingleRel:
        ...

    @property
    def extension_multi(self) -> global___ExtensionMultiRel:
        ...

    @property
    def extension_leaf(self) -> global___ExtensionLeafRel:
        ...

    @property
    def cross(self) -> global___CrossRel:
        ...

    @property
    def reference(self) -> global___ReferenceRel:
        ...

    @property
    def write(self) -> global___WriteRel:
        ...

    @property
    def ddl(self) -> global___DdlRel:
        ...

    @property
    def update(self) -> global___UpdateRel:
        ...

    @property
    def hash_join(self) -> global___HashJoinRel:
        """Physical relations"""

    @property
    def merge_join(self) -> global___MergeJoinRel:
        ...

    @property
    def nested_loop_join(self) -> global___NestedLoopJoinRel:
        ...

    @property
    def window(self) -> global___ConsistentPartitionWindowRel:
        ...

    @property
    def exchange(self) -> global___ExchangeRel:
        ...

    @property
    def expand(self) -> global___ExpandRel:
        ...

    def __init__(self, *, read: global___ReadRel | None=..., filter: global___FilterRel | None=..., fetch: global___FetchRel | None=..., aggregate: global___AggregateRel | None=..., sort: global___SortRel | None=..., join: global___JoinRel | None=..., project: global___ProjectRel | None=..., set: global___SetRel | None=..., extension_single: global___ExtensionSingleRel | None=..., extension_multi: global___ExtensionMultiRel | None=..., extension_leaf: global___ExtensionLeafRel | None=..., cross: global___CrossRel | None=..., reference: global___ReferenceRel | None=..., write: global___WriteRel | None=..., ddl: global___DdlRel | None=..., update: global___UpdateRel | None=..., hash_join: global___HashJoinRel | None=..., merge_join: global___MergeJoinRel | None=..., nested_loop_join: global___NestedLoopJoinRel | None=..., window: global___ConsistentPartitionWindowRel | None=..., exchange: global___ExchangeRel | None=..., expand: global___ExpandRel | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['aggregate', b'aggregate', 'cross', b'cross', 'ddl', b'ddl', 'exchange', b'exchange', 'expand', b'expand', 'extension_leaf', b'extension_leaf', 'extension_multi', b'extension_multi', 'extension_single', b'extension_single', 'fetch', b'fetch', 'filter', b'filter', 'hash_join', b'hash_join', 'join', b'join', 'merge_join', b'merge_join', 'nested_loop_join', b'nested_loop_join', 'project', b'project', 'read', b'read', 'reference', b'reference', 'rel_type', b'rel_type', 'set', b'set', 'sort', b'sort', 'update', b'update', 'window', b'window', 'write', b'write']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['aggregate', b'aggregate', 'cross', b'cross', 'ddl', b'ddl', 'exchange', b'exchange', 'expand', b'expand', 'extension_leaf', b'extension_leaf', 'extension_multi', b'extension_multi', 'extension_single', b'extension_single', 'fetch', b'fetch', 'filter', b'filter', 'hash_join', b'hash_join', 'join', b'join', 'merge_join', b'merge_join', 'nested_loop_join', b'nested_loop_join', 'project', b'project', 'read', b'read', 'reference', b'reference', 'rel_type', b'rel_type', 'set', b'set', 'sort', b'sort', 'update', b'update', 'window', b'window', 'write', b'write']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['rel_type', b'rel_type']) -> typing.Literal['read', 'filter', 'fetch', 'aggregate', 'sort', 'join', 'project', 'set', 'extension_single', 'extension_multi', 'extension_leaf', 'cross', 'reference', 'write', 'ddl', 'update', 'hash_join', 'merge_join', 'nested_loop_join', 'window', 'exchange', 'expand'] | None:
        ...
global___Rel = Rel

@typing.final
class NamedObjectWrite(google.protobuf.message.Message):
    """A base object for writing (e.g., a table or a view)."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAMES_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The list of string is used to represent namespacing (e.g., mydb.mytable).
        This assumes shared catalog between systems exchanging a message.
        """

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, names: collections.abc.Iterable[builtins.str] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'names', b'names']) -> None:
        ...
global___NamedObjectWrite = NamedObjectWrite

@typing.final
class ExtensionObject(google.protobuf.message.Message):
    """A stub type that can be used to extend/introduce new table types outside
    the specification.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DETAIL_FIELD_NUMBER: builtins.int

    @property
    def detail(self) -> google.protobuf.any_pb2.Any:
        ...

    def __init__(self, *, detail: google.protobuf.any_pb2.Any | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['detail', b'detail']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['detail', b'detail']) -> None:
        ...
global___ExtensionObject = ExtensionObject

@typing.final
class DdlRel(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _DdlObject:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DdlObjectEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DdlRel._DdlObject.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DDL_OBJECT_UNSPECIFIED: DdlRel._DdlObject.ValueType
        DDL_OBJECT_TABLE: DdlRel._DdlObject.ValueType
        'A Table object in the system'
        DDL_OBJECT_VIEW: DdlRel._DdlObject.ValueType
        'A View object in the system'

    class DdlObject(_DdlObject, metaclass=_DdlObjectEnumTypeWrapper):
        ...
    DDL_OBJECT_UNSPECIFIED: DdlRel.DdlObject.ValueType
    DDL_OBJECT_TABLE: DdlRel.DdlObject.ValueType
    'A Table object in the system'
    DDL_OBJECT_VIEW: DdlRel.DdlObject.ValueType
    'A View object in the system'

    class _DdlOp:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DdlOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DdlRel._DdlOp.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DDL_OP_UNSPECIFIED: DdlRel._DdlOp.ValueType
        DDL_OP_CREATE: DdlRel._DdlOp.ValueType
        'A create operation (for any object)'
        DDL_OP_CREATE_OR_REPLACE: DdlRel._DdlOp.ValueType
        'A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists'
        DDL_OP_ALTER: DdlRel._DdlOp.ValueType
        'An operation that modifies the schema (e.g., column names, types, default values) for the target object'
        DDL_OP_DROP: DdlRel._DdlOp.ValueType
        'An operation that removes an object from the system'
        DDL_OP_DROP_IF_EXIST: DdlRel._DdlOp.ValueType
        'An operation that removes an object from the system (without throwing an exception if the object did not exist)'

    class DdlOp(_DdlOp, metaclass=_DdlOpEnumTypeWrapper):
        ...
    DDL_OP_UNSPECIFIED: DdlRel.DdlOp.ValueType
    DDL_OP_CREATE: DdlRel.DdlOp.ValueType
    'A create operation (for any object)'
    DDL_OP_CREATE_OR_REPLACE: DdlRel.DdlOp.ValueType
    'A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists'
    DDL_OP_ALTER: DdlRel.DdlOp.ValueType
    'An operation that modifies the schema (e.g., column names, types, default values) for the target object'
    DDL_OP_DROP: DdlRel.DdlOp.ValueType
    'An operation that removes an object from the system'
    DDL_OP_DROP_IF_EXIST: DdlRel.DdlOp.ValueType
    'An operation that removes an object from the system (without throwing an exception if the object did not exist)'
    NAMED_OBJECT_FIELD_NUMBER: builtins.int
    EXTENSION_OBJECT_FIELD_NUMBER: builtins.int
    TABLE_SCHEMA_FIELD_NUMBER: builtins.int
    TABLE_DEFAULTS_FIELD_NUMBER: builtins.int
    OBJECT_FIELD_NUMBER: builtins.int
    OP_FIELD_NUMBER: builtins.int
    VIEW_DEFINITION_FIELD_NUMBER: builtins.int
    COMMON_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    object: global___DdlRel.DdlObject.ValueType
    'Which type of object we operate on'
    op: global___DdlRel.DdlOp.ValueType
    'The type of operation to perform'

    @property
    def named_object(self) -> global___NamedObjectWrite:
        ...

    @property
    def extension_object(self) -> global___ExtensionObject:
        ...

    @property
    def table_schema(self) -> proto.type_pb2.NamedStruct:
        """The columns that will be modified (representing after-image of a schema change)"""

    @property
    def table_defaults(self) -> global___Expression.Literal.Struct:
        """The default values for the columns (representing after-image of a schema change)
        E.g., in case of an ALTER TABLE that changes some of the column default values, we expect
        the table_defaults Struct to report a full list of default values reflecting the result of applying
        the ALTER TABLE operator successfully
        """

    @property
    def view_definition(self) -> global___Rel:
        """The body of the CREATE VIEW"""

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, named_object: global___NamedObjectWrite | None=..., extension_object: global___ExtensionObject | None=..., table_schema: proto.type_pb2.NamedStruct | None=..., table_defaults: global___Expression.Literal.Struct | None=..., object: global___DdlRel.DdlObject.ValueType=..., op: global___DdlRel.DdlOp.ValueType=..., view_definition: global___Rel | None=..., common: global___RelCommon | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'extension_object', b'extension_object', 'named_object', b'named_object', 'table_defaults', b'table_defaults', 'table_schema', b'table_schema', 'view_definition', b'view_definition', 'write_type', b'write_type']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'extension_object', b'extension_object', 'named_object', b'named_object', 'object', b'object', 'op', b'op', 'table_defaults', b'table_defaults', 'table_schema', b'table_schema', 'view_definition', b'view_definition', 'write_type', b'write_type']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['write_type', b'write_type']) -> typing.Literal['named_object', 'extension_object'] | None:
        ...
global___DdlRel = DdlRel

@typing.final
class WriteRel(google.protobuf.message.Message):
    """The operator that modifies the content of a database (operates on 1 table at a time, but record-selection/source can be
    based on joining of multiple tables).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _WriteOp:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _WriteOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[WriteRel._WriteOp.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        WRITE_OP_UNSPECIFIED: WriteRel._WriteOp.ValueType
        WRITE_OP_INSERT: WriteRel._WriteOp.ValueType
        'The insert of new records in a table'
        WRITE_OP_DELETE: WriteRel._WriteOp.ValueType
        'The removal of records from a table'
        WRITE_OP_UPDATE: WriteRel._WriteOp.ValueType
        'The modification of existing records within a table'
        WRITE_OP_CTAS: WriteRel._WriteOp.ValueType
        'The Creation of a new table, and the insert of new records in the table'

    class WriteOp(_WriteOp, metaclass=_WriteOpEnumTypeWrapper):
        ...
    WRITE_OP_UNSPECIFIED: WriteRel.WriteOp.ValueType
    WRITE_OP_INSERT: WriteRel.WriteOp.ValueType
    'The insert of new records in a table'
    WRITE_OP_DELETE: WriteRel.WriteOp.ValueType
    'The removal of records from a table'
    WRITE_OP_UPDATE: WriteRel.WriteOp.ValueType
    'The modification of existing records within a table'
    WRITE_OP_CTAS: WriteRel.WriteOp.ValueType
    'The Creation of a new table, and the insert of new records in the table'

    class _CreateMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _CreateModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[WriteRel._CreateMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        CREATE_MODE_UNSPECIFIED: WriteRel._CreateMode.ValueType
        CREATE_MODE_APPEND_IF_EXISTS: WriteRel._CreateMode.ValueType
        'Append the data to the table if it already exists'
        CREATE_MODE_REPLACE_IF_EXISTS: WriteRel._CreateMode.ValueType
        'Replace the table if it already exists ("OR REPLACE")'
        CREATE_MODE_IGNORE_IF_EXISTS: WriteRel._CreateMode.ValueType
        'Ignore the request if the table already exists ("IF NOT EXISTS")'
        CREATE_MODE_ERROR_IF_EXISTS: WriteRel._CreateMode.ValueType
        'Throw an error if the table already exists (default behavior)'

    class CreateMode(_CreateMode, metaclass=_CreateModeEnumTypeWrapper):
        ...
    CREATE_MODE_UNSPECIFIED: WriteRel.CreateMode.ValueType
    CREATE_MODE_APPEND_IF_EXISTS: WriteRel.CreateMode.ValueType
    'Append the data to the table if it already exists'
    CREATE_MODE_REPLACE_IF_EXISTS: WriteRel.CreateMode.ValueType
    'Replace the table if it already exists ("OR REPLACE")'
    CREATE_MODE_IGNORE_IF_EXISTS: WriteRel.CreateMode.ValueType
    'Ignore the request if the table already exists ("IF NOT EXISTS")'
    CREATE_MODE_ERROR_IF_EXISTS: WriteRel.CreateMode.ValueType
    'Throw an error if the table already exists (default behavior)'

    class _OutputMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OutputModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[WriteRel._OutputMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        OUTPUT_MODE_UNSPECIFIED: WriteRel._OutputMode.ValueType
        OUTPUT_MODE_NO_OUTPUT: WriteRel._OutputMode.ValueType
        'return no records at all'
        OUTPUT_MODE_MODIFIED_RECORDS: WriteRel._OutputMode.ValueType
        'this mode makes the operator return all the record INSERTED/DELETED/UPDATED by the operator.\n        The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams\n        (e.g., retunring the typical "count of modified records").\n        For scenarios in which the BEFORE image is required, the user must implement a spool (via references to\n        subplans in the body of the Rel input) and return those with anounter PlanRel.relations.\n        '

    class OutputMode(_OutputMode, metaclass=_OutputModeEnumTypeWrapper):
        ...
    OUTPUT_MODE_UNSPECIFIED: WriteRel.OutputMode.ValueType
    OUTPUT_MODE_NO_OUTPUT: WriteRel.OutputMode.ValueType
    'return no records at all'
    OUTPUT_MODE_MODIFIED_RECORDS: WriteRel.OutputMode.ValueType
    'this mode makes the operator return all the record INSERTED/DELETED/UPDATED by the operator.\n    The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams\n    (e.g., retunring the typical "count of modified records").\n    For scenarios in which the BEFORE image is required, the user must implement a spool (via references to\n    subplans in the body of the Rel input) and return those with anounter PlanRel.relations.\n    '
    NAMED_TABLE_FIELD_NUMBER: builtins.int
    EXTENSION_TABLE_FIELD_NUMBER: builtins.int
    TABLE_SCHEMA_FIELD_NUMBER: builtins.int
    OP_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    CREATE_MODE_FIELD_NUMBER: builtins.int
    OUTPUT_FIELD_NUMBER: builtins.int
    COMMON_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    op: global___WriteRel.WriteOp.ValueType
    'The type of operation to perform'
    create_mode: global___WriteRel.CreateMode.ValueType
    'Used with CTAS to determine what to do if the table already exists'
    output: global___WriteRel.OutputMode.ValueType
    'Output mode determines what is the output of executing this rel'

    @property
    def named_table(self) -> global___NamedObjectWrite:
        ...

    @property
    def extension_table(self) -> global___ExtensionObject:
        ...

    @property
    def table_schema(self) -> proto.type_pb2.NamedStruct:
        """The schema of the table (must align with Rel input (e.g., number of leaf fields must match))"""

    @property
    def input(self) -> global___Rel:
        """The relation that determines the records to add/remove/modify
        the schema must match with table_schema. Default values must be explicitly stated
        in a ProjectRel at the top of the input. The match must also
        occur in case of DELETE to ensure multi-engine plans are unequivocal.
        """

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, named_table: global___NamedObjectWrite | None=..., extension_table: global___ExtensionObject | None=..., table_schema: proto.type_pb2.NamedStruct | None=..., op: global___WriteRel.WriteOp.ValueType=..., input: global___Rel | None=..., create_mode: global___WriteRel.CreateMode.ValueType=..., output: global___WriteRel.OutputMode.ValueType=..., common: global___RelCommon | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'extension_table', b'extension_table', 'input', b'input', 'named_table', b'named_table', 'table_schema', b'table_schema', 'write_type', b'write_type']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'create_mode', b'create_mode', 'extension_table', b'extension_table', 'input', b'input', 'named_table', b'named_table', 'op', b'op', 'output', b'output', 'table_schema', b'table_schema', 'write_type', b'write_type']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['write_type', b'write_type']) -> typing.Literal['named_table', 'extension_table'] | None:
        ...
global___WriteRel = WriteRel

@typing.final
class UpdateRel(google.protobuf.message.Message):
    """The operator that modifies the columns of a table"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class TransformExpression(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TRANSFORMATION_FIELD_NUMBER: builtins.int
        COLUMN_TARGET_FIELD_NUMBER: builtins.int
        column_target: builtins.int
        'index of the column to apply the transformation to'

        @property
        def transformation(self) -> global___Expression:
            """the transformation to apply"""

        def __init__(self, *, transformation: global___Expression | None=..., column_target: builtins.int=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['transformation', b'transformation']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['column_target', b'column_target', 'transformation', b'transformation']) -> None:
            ...
    NAMED_TABLE_FIELD_NUMBER: builtins.int
    TABLE_SCHEMA_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    TRANSFORMATIONS_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def named_table(self) -> global___NamedTable:
        ...

    @property
    def table_schema(self) -> proto.type_pb2.NamedStruct:
        """The full schema of the named_table"""

    @property
    def condition(self) -> global___Expression:
        """condition to be met for the update to be applied on a record"""

    @property
    def transformations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UpdateRel.TransformExpression]:
        """The list of transformations to apply to the columns of the named_table"""

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, named_table: global___NamedTable | None=..., table_schema: proto.type_pb2.NamedStruct | None=..., condition: global___Expression | None=..., transformations: collections.abc.Iterable[global___UpdateRel.TransformExpression] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'condition', b'condition', 'named_table', b'named_table', 'table_schema', b'table_schema', 'update_type', b'update_type']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'condition', b'condition', 'named_table', b'named_table', 'table_schema', b'table_schema', 'transformations', b'transformations', 'update_type', b'update_type']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['update_type', b'update_type']) -> typing.Literal['named_table'] | None:
        ...
global___UpdateRel = UpdateRel

@typing.final
class NamedTable(google.protobuf.message.Message):
    """A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).
    This assumes shared catalog between systems exchanging a message.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAMES_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int

    @property
    def names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, names: collections.abc.Iterable[builtins.str] | None=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'names', b'names']) -> None:
        ...
global___NamedTable = NamedTable

@typing.final
class ComparisonJoinKey(google.protobuf.message.Message):
    """Hash joins and merge joins are a specialization of the general join where the join
    expression is an series of comparisons between fields that are ANDed together.  The
    behavior of this comparison is flexible
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SimpleComparisonType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SimpleComparisonTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ComparisonJoinKey._SimpleComparisonType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SIMPLE_COMPARISON_TYPE_UNSPECIFIED: ComparisonJoinKey._SimpleComparisonType.ValueType
        SIMPLE_COMPARISON_TYPE_EQ: ComparisonJoinKey._SimpleComparisonType.ValueType
        'Returns true only if both values are equal and not null'
        SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM: ComparisonJoinKey._SimpleComparisonType.ValueType
        'Returns true if both values are equal and not null\n        Returns true if both values are null\n        Returns false if one value is null and the other value is not null\n\n        This can be expressed as a = b OR (isnull(a) AND isnull(b))\n        '
        SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL: ComparisonJoinKey._SimpleComparisonType.ValueType
        'Returns true if both values are equal and not null\n        Returns true if either value is null\n\n        This can be expressed as a = b OR isnull(a = b)\n        '

    class SimpleComparisonType(_SimpleComparisonType, metaclass=_SimpleComparisonTypeEnumTypeWrapper):
        """Most joins will use one of the following behaviors.  To avoid the complexity
        of a function lookup we define the common behaviors here
        """
    SIMPLE_COMPARISON_TYPE_UNSPECIFIED: ComparisonJoinKey.SimpleComparisonType.ValueType
    SIMPLE_COMPARISON_TYPE_EQ: ComparisonJoinKey.SimpleComparisonType.ValueType
    'Returns true only if both values are equal and not null'
    SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM: ComparisonJoinKey.SimpleComparisonType.ValueType
    'Returns true if both values are equal and not null\n    Returns true if both values are null\n    Returns false if one value is null and the other value is not null\n\n    This can be expressed as a = b OR (isnull(a) AND isnull(b))\n    '
    SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL: ComparisonJoinKey.SimpleComparisonType.ValueType
    'Returns true if both values are equal and not null\n    Returns true if either value is null\n\n    This can be expressed as a = b OR isnull(a = b)\n    '

    @typing.final
    class ComparisonType(google.protobuf.message.Message):
        """Describes how the relation should consider if two rows are a match"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        SIMPLE_FIELD_NUMBER: builtins.int
        CUSTOM_FUNCTION_REFERENCE_FIELD_NUMBER: builtins.int
        simple: global___ComparisonJoinKey.SimpleComparisonType.ValueType
        'One of the simple comparison behaviors is used'
        custom_function_reference: builtins.int
        'A custom comparison behavior is used.  This can happen, for example, when using\n        collations, where we might want to do something like a case-insensitive comparison.\n\n        This must be a binary function with a boolean return type\n        '

        def __init__(self, *, simple: global___ComparisonJoinKey.SimpleComparisonType.ValueType=..., custom_function_reference: builtins.int=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['custom_function_reference', b'custom_function_reference', 'inner_type', b'inner_type', 'simple', b'simple']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['custom_function_reference', b'custom_function_reference', 'inner_type', b'inner_type', 'simple', b'simple']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['inner_type', b'inner_type']) -> typing.Literal['simple', 'custom_function_reference'] | None:
            ...
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    COMPARISON_FIELD_NUMBER: builtins.int

    @property
    def left(self) -> global___Expression.FieldReference:
        """The key to compare from the left table"""

    @property
    def right(self) -> global___Expression.FieldReference:
        """The key to compare from the right table"""

    @property
    def comparison(self) -> global___ComparisonJoinKey.ComparisonType:
        """Describes how to compare the two keys"""

    def __init__(self, *, left: global___Expression.FieldReference | None=..., right: global___Expression.FieldReference | None=..., comparison: global___ComparisonJoinKey.ComparisonType | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['comparison', b'comparison', 'left', b'left', 'right', b'right']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['comparison', b'comparison', 'left', b'left', 'right', b'right']) -> None:
        ...
global___ComparisonJoinKey = ComparisonJoinKey

@typing.final
class HashJoinRel(google.protobuf.message.Message):
    """The hash equijoin operator will build a hash table out of one input (default `right`) based on a set of join keys.
    It will then probe that hash table for the other input (default `left`), finding matches.

    Two rows are a match if the comparison function returns true for all keys
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _JoinType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _JoinTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[HashJoinRel._JoinType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        JOIN_TYPE_UNSPECIFIED: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_INNER: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_OUTER: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SEMI: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SEMI: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_ANTI: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_ANTI: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SINGLE: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SINGLE: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_MARK: HashJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_MARK: HashJoinRel._JoinType.ValueType

    class JoinType(_JoinType, metaclass=_JoinTypeEnumTypeWrapper):
        ...
    JOIN_TYPE_UNSPECIFIED: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_INNER: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_OUTER: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SEMI: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SEMI: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_ANTI: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_ANTI: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SINGLE: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SINGLE: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_MARK: HashJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_MARK: HashJoinRel.JoinType.ValueType

    class _BuildInput:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _BuildInputEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[HashJoinRel._BuildInput.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        BUILD_INPUT_UNSPECIFIED: HashJoinRel._BuildInput.ValueType
        BUILD_INPUT_LEFT: HashJoinRel._BuildInput.ValueType
        BUILD_INPUT_RIGHT: HashJoinRel._BuildInput.ValueType

    class BuildInput(_BuildInput, metaclass=_BuildInputEnumTypeWrapper):
        ...
    BUILD_INPUT_UNSPECIFIED: HashJoinRel.BuildInput.ValueType
    BUILD_INPUT_LEFT: HashJoinRel.BuildInput.ValueType
    BUILD_INPUT_RIGHT: HashJoinRel.BuildInput.ValueType
    COMMON_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    LEFT_KEYS_FIELD_NUMBER: builtins.int
    RIGHT_KEYS_FIELD_NUMBER: builtins.int
    KEYS_FIELD_NUMBER: builtins.int
    POST_JOIN_FILTER_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    BUILD_INPUT_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    type: global___HashJoinRel.JoinType.ValueType
    build_input: global___HashJoinRel.BuildInput.ValueType
    'Specifies which side of input to build the hash table for this hash join. Default is `BUILD_INPUT_RIGHT`.'

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def left(self) -> global___Rel:
        ...

    @property
    def right(self) -> global___Rel:
        ...

    @property
    def left_keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.FieldReference]:
        """These fields are deprecated in favor of `keys`.  If they are set then
        the two lists (left_keys and right_keys) must have the same length and
        the comparion function is considered to be SimpleEqualityType::EQ
        """

    @property
    def right_keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.FieldReference]:
        ...

    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ComparisonJoinKey]:
        """One or more keys to join on.  The relation is invalid if this is empty
        (unless the deprecated left_keys/right_keys fields are being used).

        If a custom comparison function is used then it must be consistent with
        the hash function used for the keys.

        In other words, the hash function must return the same hash code when the
        comparison returns true.  For example, if the comparison function is
        "equals ignoring case" then the hash function must return the same hash
        code for strings that differ only by case.  Note: the hash function is not
        specified here.  It is the responsibility of the consumer to find an appropriate
        hash function for a given comparsion function or to reject the plan if it cannot
        do so.
        """

    @property
    def post_join_filter(self) -> global___Expression:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., left: global___Rel | None=..., right: global___Rel | None=..., left_keys: collections.abc.Iterable[global___Expression.FieldReference] | None=..., right_keys: collections.abc.Iterable[global___Expression.FieldReference] | None=..., keys: collections.abc.Iterable[global___ComparisonJoinKey] | None=..., post_join_filter: global___Expression | None=..., type: global___HashJoinRel.JoinType.ValueType=..., build_input: global___HashJoinRel.BuildInput.ValueType=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'left', b'left', 'post_join_filter', b'post_join_filter', 'right', b'right']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'build_input', b'build_input', 'common', b'common', 'keys', b'keys', 'left', b'left', 'left_keys', b'left_keys', 'post_join_filter', b'post_join_filter', 'right', b'right', 'right_keys', b'right_keys', 'type', b'type']) -> None:
        ...
global___HashJoinRel = HashJoinRel

@typing.final
class MergeJoinRel(google.protobuf.message.Message):
    """The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys.
    This allows the join operation to be done in a streaming fashion.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _JoinType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _JoinTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[MergeJoinRel._JoinType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        JOIN_TYPE_UNSPECIFIED: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_INNER: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_OUTER: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SEMI: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SEMI: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_ANTI: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_ANTI: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SINGLE: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SINGLE: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_MARK: MergeJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_MARK: MergeJoinRel._JoinType.ValueType

    class JoinType(_JoinType, metaclass=_JoinTypeEnumTypeWrapper):
        ...
    JOIN_TYPE_UNSPECIFIED: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_INNER: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_OUTER: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SEMI: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SEMI: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_ANTI: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_ANTI: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SINGLE: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SINGLE: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_MARK: MergeJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_MARK: MergeJoinRel.JoinType.ValueType
    COMMON_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    LEFT_KEYS_FIELD_NUMBER: builtins.int
    RIGHT_KEYS_FIELD_NUMBER: builtins.int
    KEYS_FIELD_NUMBER: builtins.int
    POST_JOIN_FILTER_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    type: global___MergeJoinRel.JoinType.ValueType

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def left(self) -> global___Rel:
        ...

    @property
    def right(self) -> global___Rel:
        ...

    @property
    def left_keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.FieldReference]:
        """These fields are deprecated in favor of `keys`.  If they are set then
        the two lists (left_keys and right_keys) must have the same length and
        the comparion function is considered to be SimpleEqualityType::EQ
        """

    @property
    def right_keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.FieldReference]:
        ...

    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ComparisonJoinKey]:
        """One or more keys to join on.  The relation is invalid if this is empty
        (unless the deprecated left_keys/right_keys fields are being used).

        If a custom comparison function is used then it must be consistent with
        the ordering of the input data.  For example, if the comparison function
        is "<" then we generally expect the data to be sorted in ascending order.

        If the comparison function is something like "less than ignoring case" then
        the data should be sorted appropriately (e.g. both "A" and "a" should come
        before "b")

        The sort order is not specified here.  It is typically the responsibility of
        the producer to ensure the plan sorts the data if needed (although the consumer
        is free to do so as well).  If possible, the consumer should verify the sort
        order and reject invalid plans.
        """

    @property
    def post_join_filter(self) -> global___Expression:
        ...

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., left: global___Rel | None=..., right: global___Rel | None=..., left_keys: collections.abc.Iterable[global___Expression.FieldReference] | None=..., right_keys: collections.abc.Iterable[global___Expression.FieldReference] | None=..., keys: collections.abc.Iterable[global___ComparisonJoinKey] | None=..., post_join_filter: global___Expression | None=..., type: global___MergeJoinRel.JoinType.ValueType=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'left', b'left', 'post_join_filter', b'post_join_filter', 'right', b'right']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'keys', b'keys', 'left', b'left', 'left_keys', b'left_keys', 'post_join_filter', b'post_join_filter', 'right', b'right', 'right_keys', b'right_keys', 'type', b'type']) -> None:
        ...
global___MergeJoinRel = MergeJoinRel

@typing.final
class NestedLoopJoinRel(google.protobuf.message.Message):
    """The nested loop join (NLJ) operator will hold the entire right input and iterate over it using the
    left input, evaluating the join expression on the Cartesian product of all rows.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _JoinType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _JoinTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NestedLoopJoinRel._JoinType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        JOIN_TYPE_UNSPECIFIED: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_INNER: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_OUTER: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SEMI: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SEMI: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_ANTI: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_ANTI: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_SINGLE: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_SINGLE: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_LEFT_MARK: NestedLoopJoinRel._JoinType.ValueType
        JOIN_TYPE_RIGHT_MARK: NestedLoopJoinRel._JoinType.ValueType

    class JoinType(_JoinType, metaclass=_JoinTypeEnumTypeWrapper):
        ...
    JOIN_TYPE_UNSPECIFIED: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_INNER: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_OUTER: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SEMI: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SEMI: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_ANTI: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_ANTI: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_SINGLE: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_SINGLE: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_LEFT_MARK: NestedLoopJoinRel.JoinType.ValueType
    JOIN_TYPE_RIGHT_MARK: NestedLoopJoinRel.JoinType.ValueType
    COMMON_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    EXPRESSION_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSION_FIELD_NUMBER: builtins.int
    type: global___NestedLoopJoinRel.JoinType.ValueType

    @property
    def common(self) -> global___RelCommon:
        ...

    @property
    def left(self) -> global___Rel:
        ...

    @property
    def right(self) -> global___Rel:
        ...

    @property
    def expression(self) -> global___Expression:
        """optional, defaults to true (a cartesian join)"""

    @property
    def advanced_extension(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        ...

    def __init__(self, *, common: global___RelCommon | None=..., left: global___Rel | None=..., right: global___Rel | None=..., expression: global___Expression | None=..., type: global___NestedLoopJoinRel.JoinType.ValueType=..., advanced_extension: proto.extensions.extensions_pb2.AdvancedExtension | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'expression', b'expression', 'left', b'left', 'right', b'right']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['advanced_extension', b'advanced_extension', 'common', b'common', 'expression', b'expression', 'left', b'left', 'right', b'right', 'type', b'type']) -> None:
        ...
global___NestedLoopJoinRel = NestedLoopJoinRel

@typing.final
class FunctionArgument(google.protobuf.message.Message):
    """The argument of a function"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ENUM_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    enum: builtins.str

    @property
    def type(self) -> proto.type_pb2.Type:
        ...

    @property
    def value(self) -> global___Expression:
        ...

    def __init__(self, *, enum: builtins.str=..., type: proto.type_pb2.Type | None=..., value: global___Expression | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['arg_type', b'arg_type', 'enum', b'enum', 'type', b'type', 'value', b'value']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['arg_type', b'arg_type', 'enum', b'enum', 'type', b'type', 'value', b'value']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['arg_type', b'arg_type']) -> typing.Literal['enum', 'type', 'value'] | None:
        ...
global___FunctionArgument = FunctionArgument

@typing.final
class FunctionOption(google.protobuf.message.Message):
    """An optional function argument.  Typically used for specifying behavior in
    invalid or corner cases.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    PREFERENCE_FIELD_NUMBER: builtins.int
    name: builtins.str
    'Name of the option to set. If the consumer does not recognize the\n    option, it must reject the plan. The name is matched case-insensitively\n    with option names defined for the function.\n    '

    @property
    def preference(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """List of behavior options allowed by the producer. At least one must be
        specified; to leave an option unspecified, simply don't add an entry to
        `options`. The consumer must use the first option from the list that it
        supports. If the consumer supports none of the specified options, it
        must reject the plan. The name is matched case-insensitively and must
        match one of the option values defined for the option.
        """

    def __init__(self, *, name: builtins.str=..., preference: collections.abc.Iterable[builtins.str] | None=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['name', b'name', 'preference', b'preference']) -> None:
        ...
global___FunctionOption = FunctionOption

@typing.final
class Expression(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Enum(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class Empty(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            def __init__(self) -> None:
                ...
        SPECIFIED_FIELD_NUMBER: builtins.int
        UNSPECIFIED_FIELD_NUMBER: builtins.int
        specified: builtins.str

        @property
        def unspecified(self) -> global___Expression.Enum.Empty:
            ...

        def __init__(self, *, specified: builtins.str=..., unspecified: global___Expression.Enum.Empty | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['enum_kind', b'enum_kind', 'specified', b'specified', 'unspecified', b'unspecified']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['enum_kind', b'enum_kind', 'specified', b'specified', 'unspecified', b'unspecified']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['enum_kind', b'enum_kind']) -> typing.Literal['specified', 'unspecified'] | None:
            ...

    @typing.final
    class Literal(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class VarChar(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            VALUE_FIELD_NUMBER: builtins.int
            LENGTH_FIELD_NUMBER: builtins.int
            value: builtins.str
            length: builtins.int

            def __init__(self, *, value: builtins.str=..., length: builtins.int=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['length', b'length', 'value', b'value']) -> None:
                ...

        @typing.final
        class Decimal(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            VALUE_FIELD_NUMBER: builtins.int
            PRECISION_FIELD_NUMBER: builtins.int
            SCALE_FIELD_NUMBER: builtins.int
            value: builtins.bytes
            'little-endian twos-complement integer representation of complete value\n            (ignoring precision) Always 16 bytes in length\n            '
            precision: builtins.int
            'The maximum number of digits allowed in the value.\n            the maximum precision is 38.\n            '
            scale: builtins.int
            'declared scale of decimal literal'

            def __init__(self, *, value: builtins.bytes=..., precision: builtins.int=..., scale: builtins.int=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['precision', b'precision', 'scale', b'scale', 'value', b'value']) -> None:
                ...

        @typing.final
        class PrecisionTime(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            PRECISION_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            precision: builtins.int
            'Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds, 12 is picoseconds'
            value: builtins.int
            'Time passed since midnight in precision units.'

            def __init__(self, *, precision: builtins.int=..., value: builtins.int=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['precision', b'precision', 'value', b'value']) -> None:
                ...

        @typing.final
        class PrecisionTimestamp(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            PRECISION_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            precision: builtins.int
            'Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds, 12 is picoseconds'
            value: builtins.int
            'Time passed since 1970-01-01 00:00:00.000000 in UTC for PrecisionTimestampTZ and unspecified timezone for PrecisionTimestamp'

            def __init__(self, *, precision: builtins.int=..., value: builtins.int=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['precision', b'precision', 'value', b'value']) -> None:
                ...

        @typing.final
        class Map(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            @typing.final
            class KeyValue(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                KEY_FIELD_NUMBER: builtins.int
                VALUE_FIELD_NUMBER: builtins.int

                @property
                def key(self) -> global___Expression.Literal:
                    ...

                @property
                def value(self) -> global___Expression.Literal:
                    ...

                def __init__(self, *, key: global___Expression.Literal | None=..., value: global___Expression.Literal | None=...) -> None:
                    ...

                def HasField(self, field_name: typing.Literal['key', b'key', 'value', b'value']) -> builtins.bool:
                    ...

                def ClearField(self, field_name: typing.Literal['key', b'key', 'value', b'value']) -> None:
                    ...
            KEY_VALUES_FIELD_NUMBER: builtins.int

            @property
            def key_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.Literal.Map.KeyValue]:
                ...

            def __init__(self, *, key_values: collections.abc.Iterable[global___Expression.Literal.Map.KeyValue] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['key_values', b'key_values']) -> None:
                ...

        @typing.final
        class IntervalYearToMonth(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            YEARS_FIELD_NUMBER: builtins.int
            MONTHS_FIELD_NUMBER: builtins.int
            years: builtins.int
            months: builtins.int

            def __init__(self, *, years: builtins.int=..., months: builtins.int=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['months', b'months', 'years', b'years']) -> None:
                ...

        @typing.final
        class IntervalDayToSecond(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            DAYS_FIELD_NUMBER: builtins.int
            SECONDS_FIELD_NUMBER: builtins.int
            MICROSECONDS_FIELD_NUMBER: builtins.int
            PRECISION_FIELD_NUMBER: builtins.int
            SUBSECONDS_FIELD_NUMBER: builtins.int
            days: builtins.int
            seconds: builtins.int
            microseconds: builtins.int
            'use precision and subseconds below, they cover and replace microseconds.'
            precision: builtins.int
            'Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds. Should be used with subseconds below.'
            subseconds: builtins.int
            'the number of fractional seconds using 1e(-precision) units. Should only be used with precision field, not microseconds.'

            def __init__(self, *, days: builtins.int=..., seconds: builtins.int=..., microseconds: builtins.int=..., precision: builtins.int=..., subseconds: builtins.int=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['microseconds', b'microseconds', 'precision', b'precision', 'precision_mode', b'precision_mode']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['days', b'days', 'microseconds', b'microseconds', 'precision', b'precision', 'precision_mode', b'precision_mode', 'seconds', b'seconds', 'subseconds', b'subseconds']) -> None:
                ...

            def WhichOneof(self, oneof_group: typing.Literal['precision_mode', b'precision_mode']) -> typing.Literal['microseconds', 'precision'] | None:
                ...

        @typing.final
        class IntervalCompound(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            INTERVAL_YEAR_TO_MONTH_FIELD_NUMBER: builtins.int
            INTERVAL_DAY_TO_SECOND_FIELD_NUMBER: builtins.int

            @property
            def interval_year_to_month(self) -> global___Expression.Literal.IntervalYearToMonth:
                ...

            @property
            def interval_day_to_second(self) -> global___Expression.Literal.IntervalDayToSecond:
                ...

            def __init__(self, *, interval_year_to_month: global___Expression.Literal.IntervalYearToMonth | None=..., interval_day_to_second: global___Expression.Literal.IntervalDayToSecond | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['interval_day_to_second', b'interval_day_to_second', 'interval_year_to_month', b'interval_year_to_month']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['interval_day_to_second', b'interval_day_to_second', 'interval_year_to_month', b'interval_year_to_month']) -> None:
                ...

        @typing.final
        class Struct(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            FIELDS_FIELD_NUMBER: builtins.int

            @property
            def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.Literal]:
                """A possibly heterogeneously typed list of literals"""

            def __init__(self, *, fields: collections.abc.Iterable[global___Expression.Literal] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['fields', b'fields']) -> None:
                ...

        @typing.final
        class List(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            VALUES_FIELD_NUMBER: builtins.int

            @property
            def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.Literal]:
                """A homogeneously typed list of literals"""

            def __init__(self, *, values: collections.abc.Iterable[global___Expression.Literal] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['values', b'values']) -> None:
                ...

        @typing.final
        class UserDefined(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            TYPE_REFERENCE_FIELD_NUMBER: builtins.int
            TYPE_PARAMETERS_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            STRUCT_FIELD_NUMBER: builtins.int
            type_reference: builtins.int
            'points to a type_anchor defined in this plan'

            @property
            def type_parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[proto.type_pb2.Type.Parameter]:
                """The parameters to be bound to the type class, if the type class is
                parameterizable.
                """

            @property
            def value(self) -> google.protobuf.any_pb2.Any:
                """the value of the literal, serialized using some type-specific protobuf message"""

            @property
            def struct(self) -> global___Expression.Literal.Struct:
                """the value of the literal, serialized using the structure definition in its declaration"""

            def __init__(self, *, type_reference: builtins.int=..., type_parameters: collections.abc.Iterable[proto.type_pb2.Type.Parameter] | None=..., value: google.protobuf.any_pb2.Any | None=..., struct: global___Expression.Literal.Struct | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['struct', b'struct', 'val', b'val', 'value', b'value']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['struct', b'struct', 'type_parameters', b'type_parameters', 'type_reference', b'type_reference', 'val', b'val', 'value', b'value']) -> None:
                ...

            def WhichOneof(self, oneof_group: typing.Literal['val', b'val']) -> typing.Literal['value', 'struct'] | None:
                ...
        BOOLEAN_FIELD_NUMBER: builtins.int
        I8_FIELD_NUMBER: builtins.int
        I16_FIELD_NUMBER: builtins.int
        I32_FIELD_NUMBER: builtins.int
        I64_FIELD_NUMBER: builtins.int
        FP32_FIELD_NUMBER: builtins.int
        FP64_FIELD_NUMBER: builtins.int
        STRING_FIELD_NUMBER: builtins.int
        BINARY_FIELD_NUMBER: builtins.int
        TIMESTAMP_FIELD_NUMBER: builtins.int
        DATE_FIELD_NUMBER: builtins.int
        TIME_FIELD_NUMBER: builtins.int
        INTERVAL_YEAR_TO_MONTH_FIELD_NUMBER: builtins.int
        INTERVAL_DAY_TO_SECOND_FIELD_NUMBER: builtins.int
        INTERVAL_COMPOUND_FIELD_NUMBER: builtins.int
        FIXED_CHAR_FIELD_NUMBER: builtins.int
        VAR_CHAR_FIELD_NUMBER: builtins.int
        FIXED_BINARY_FIELD_NUMBER: builtins.int
        DECIMAL_FIELD_NUMBER: builtins.int
        PRECISION_TIME_FIELD_NUMBER: builtins.int
        PRECISION_TIMESTAMP_FIELD_NUMBER: builtins.int
        PRECISION_TIMESTAMP_TZ_FIELD_NUMBER: builtins.int
        STRUCT_FIELD_NUMBER: builtins.int
        MAP_FIELD_NUMBER: builtins.int
        TIMESTAMP_TZ_FIELD_NUMBER: builtins.int
        UUID_FIELD_NUMBER: builtins.int
        NULL_FIELD_NUMBER: builtins.int
        LIST_FIELD_NUMBER: builtins.int
        EMPTY_LIST_FIELD_NUMBER: builtins.int
        EMPTY_MAP_FIELD_NUMBER: builtins.int
        USER_DEFINED_FIELD_NUMBER: builtins.int
        NULLABLE_FIELD_NUMBER: builtins.int
        TYPE_VARIATION_REFERENCE_FIELD_NUMBER: builtins.int
        boolean: builtins.bool
        i8: builtins.int
        i16: builtins.int
        i32: builtins.int
        i64: builtins.int
        fp32: builtins.float
        fp64: builtins.float
        string: builtins.str
        binary: builtins.bytes
        timestamp: builtins.int
        'Timestamp in units of microseconds since the UNIX epoch.\n        Deprecated in favor of `precision_timestamp`.\n        '
        date: builtins.int
        'Date in units of days since the UNIX epoch.'
        time: builtins.int
        'Time in units of microseconds past midnight.\n        Deprecated in favor of `precision_time`.\n        '
        fixed_char: builtins.str
        fixed_binary: builtins.bytes
        timestamp_tz: builtins.int
        'Timestamp in units of microseconds since the UNIX epoch.\n        Deprecated in favor of `precision_timestamp_tz`\n        '
        uuid: builtins.bytes
        nullable: builtins.bool
        'Whether the literal_type above should be treated as a nullable type.\n        Applies to all members of the literal_type oneof EXCEPT:\n         * Type null             (must be nullable by definition)\n         * Type.List empty_list  (use Type.List::nullability)\n         * Type.Map empty_map    (use Type.Map::nullability)\n        '
        type_variation_reference: builtins.int
        'optionally points to a type_variation_anchor defined in this plan.\n        Applies to all members of union other than the Typed null (which should\n        directly declare the type variation).\n        '

        @property
        def interval_year_to_month(self) -> global___Expression.Literal.IntervalYearToMonth:
            ...

        @property
        def interval_day_to_second(self) -> global___Expression.Literal.IntervalDayToSecond:
            ...

        @property
        def interval_compound(self) -> global___Expression.Literal.IntervalCompound:
            ...

        @property
        def var_char(self) -> global___Expression.Literal.VarChar:
            ...

        @property
        def decimal(self) -> global___Expression.Literal.Decimal:
            ...

        @property
        def precision_time(self) -> global___Expression.Literal.PrecisionTime:
            """Time in precision units past midnight."""

        @property
        def precision_timestamp(self) -> global___Expression.Literal.PrecisionTimestamp:
            ...

        @property
        def precision_timestamp_tz(self) -> global___Expression.Literal.PrecisionTimestamp:
            ...

        @property
        def struct(self) -> global___Expression.Literal.Struct:
            ...

        @property
        def map(self) -> global___Expression.Literal.Map:
            ...

        @property
        def null(self) -> proto.type_pb2.Type:
            """a typed null literal"""

        @property
        def list(self) -> global___Expression.Literal.List:
            ...

        @property
        def empty_list(self) -> proto.type_pb2.Type.List:
            ...

        @property
        def empty_map(self) -> proto.type_pb2.Type.Map:
            ...

        @property
        def user_defined(self) -> global___Expression.Literal.UserDefined:
            ...

        def __init__(self, *, boolean: builtins.bool=..., i8: builtins.int=..., i16: builtins.int=..., i32: builtins.int=..., i64: builtins.int=..., fp32: builtins.float=..., fp64: builtins.float=..., string: builtins.str=..., binary: builtins.bytes=..., timestamp: builtins.int=..., date: builtins.int=..., time: builtins.int=..., interval_year_to_month: global___Expression.Literal.IntervalYearToMonth | None=..., interval_day_to_second: global___Expression.Literal.IntervalDayToSecond | None=..., interval_compound: global___Expression.Literal.IntervalCompound | None=..., fixed_char: builtins.str=..., var_char: global___Expression.Literal.VarChar | None=..., fixed_binary: builtins.bytes=..., decimal: global___Expression.Literal.Decimal | None=..., precision_time: global___Expression.Literal.PrecisionTime | None=..., precision_timestamp: global___Expression.Literal.PrecisionTimestamp | None=..., precision_timestamp_tz: global___Expression.Literal.PrecisionTimestamp | None=..., struct: global___Expression.Literal.Struct | None=..., map: global___Expression.Literal.Map | None=..., timestamp_tz: builtins.int=..., uuid: builtins.bytes=..., null: proto.type_pb2.Type | None=..., list: global___Expression.Literal.List | None=..., empty_list: proto.type_pb2.Type.List | None=..., empty_map: proto.type_pb2.Type.Map | None=..., user_defined: global___Expression.Literal.UserDefined | None=..., nullable: builtins.bool=..., type_variation_reference: builtins.int=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['binary', b'binary', 'boolean', b'boolean', 'date', b'date', 'decimal', b'decimal', 'empty_list', b'empty_list', 'empty_map', b'empty_map', 'fixed_binary', b'fixed_binary', 'fixed_char', b'fixed_char', 'fp32', b'fp32', 'fp64', b'fp64', 'i16', b'i16', 'i32', b'i32', 'i64', b'i64', 'i8', b'i8', 'interval_compound', b'interval_compound', 'interval_day_to_second', b'interval_day_to_second', 'interval_year_to_month', b'interval_year_to_month', 'list', b'list', 'literal_type', b'literal_type', 'map', b'map', 'null', b'null', 'precision_time', b'precision_time', 'precision_timestamp', b'precision_timestamp', 'precision_timestamp_tz', b'precision_timestamp_tz', 'string', b'string', 'struct', b'struct', 'time', b'time', 'timestamp', b'timestamp', 'timestamp_tz', b'timestamp_tz', 'user_defined', b'user_defined', 'uuid', b'uuid', 'var_char', b'var_char']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['binary', b'binary', 'boolean', b'boolean', 'date', b'date', 'decimal', b'decimal', 'empty_list', b'empty_list', 'empty_map', b'empty_map', 'fixed_binary', b'fixed_binary', 'fixed_char', b'fixed_char', 'fp32', b'fp32', 'fp64', b'fp64', 'i16', b'i16', 'i32', b'i32', 'i64', b'i64', 'i8', b'i8', 'interval_compound', b'interval_compound', 'interval_day_to_second', b'interval_day_to_second', 'interval_year_to_month', b'interval_year_to_month', 'list', b'list', 'literal_type', b'literal_type', 'map', b'map', 'null', b'null', 'nullable', b'nullable', 'precision_time', b'precision_time', 'precision_timestamp', b'precision_timestamp', 'precision_timestamp_tz', b'precision_timestamp_tz', 'string', b'string', 'struct', b'struct', 'time', b'time', 'timestamp', b'timestamp', 'timestamp_tz', b'timestamp_tz', 'type_variation_reference', b'type_variation_reference', 'user_defined', b'user_defined', 'uuid', b'uuid', 'var_char', b'var_char']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['literal_type', b'literal_type']) -> typing.Literal['boolean', 'i8', 'i16', 'i32', 'i64', 'fp32', 'fp64', 'string', 'binary', 'timestamp', 'date', 'time', 'interval_year_to_month', 'interval_day_to_second', 'interval_compound', 'fixed_char', 'var_char', 'fixed_binary', 'decimal', 'precision_time', 'precision_timestamp', 'precision_timestamp_tz', 'struct', 'map', 'timestamp_tz', 'uuid', 'null', 'list', 'empty_list', 'empty_map', 'user_defined'] | None:
            ...

    @typing.final
    class Nested(google.protobuf.message.Message):
        """Expression to dynamically construct nested types."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class Map(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            @typing.final
            class KeyValue(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                KEY_FIELD_NUMBER: builtins.int
                VALUE_FIELD_NUMBER: builtins.int

                @property
                def key(self) -> global___Expression:
                    """Mandatory key/value expressions."""

                @property
                def value(self) -> global___Expression:
                    ...

                def __init__(self, *, key: global___Expression | None=..., value: global___Expression | None=...) -> None:
                    ...

                def HasField(self, field_name: typing.Literal['key', b'key', 'value', b'value']) -> builtins.bool:
                    ...

                def ClearField(self, field_name: typing.Literal['key', b'key', 'value', b'value']) -> None:
                    ...
            KEY_VALUES_FIELD_NUMBER: builtins.int

            @property
            def key_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.Nested.Map.KeyValue]:
                """One or more key-value pairs. To specify an empty map, use
                Literal.empty_map (otherwise type information would be missing).
                """

            def __init__(self, *, key_values: collections.abc.Iterable[global___Expression.Nested.Map.KeyValue] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['key_values', b'key_values']) -> None:
                ...

        @typing.final
        class Struct(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            FIELDS_FIELD_NUMBER: builtins.int

            @property
            def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
                """Zero or more possibly heterogeneously-typed list of expressions that
                form the struct fields.
                """

            def __init__(self, *, fields: collections.abc.Iterable[global___Expression] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['fields', b'fields']) -> None:
                ...

        @typing.final
        class List(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            VALUES_FIELD_NUMBER: builtins.int

            @property
            def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
                """A homogeneously-typed list of one or more expressions that form the
                list entries. To specify an empty list, use Literal.empty_list
                (otherwise type information would be missing).
                """

            def __init__(self, *, values: collections.abc.Iterable[global___Expression] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['values', b'values']) -> None:
                ...
        NULLABLE_FIELD_NUMBER: builtins.int
        TYPE_VARIATION_REFERENCE_FIELD_NUMBER: builtins.int
        STRUCT_FIELD_NUMBER: builtins.int
        LIST_FIELD_NUMBER: builtins.int
        MAP_FIELD_NUMBER: builtins.int
        nullable: builtins.bool
        'Whether the returned nested type is nullable.'
        type_variation_reference: builtins.int
        'Optionally points to a type_variation_anchor defined in this plan for\n        the returned nested type.\n        '

        @property
        def struct(self) -> global___Expression.Nested.Struct:
            ...

        @property
        def list(self) -> global___Expression.Nested.List:
            ...

        @property
        def map(self) -> global___Expression.Nested.Map:
            ...

        def __init__(self, *, nullable: builtins.bool=..., type_variation_reference: builtins.int=..., struct: global___Expression.Nested.Struct | None=..., list: global___Expression.Nested.List | None=..., map: global___Expression.Nested.Map | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['list', b'list', 'map', b'map', 'nested_type', b'nested_type', 'struct', b'struct']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['list', b'list', 'map', b'map', 'nested_type', b'nested_type', 'nullable', b'nullable', 'struct', b'struct', 'type_variation_reference', b'type_variation_reference']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['nested_type', b'nested_type']) -> typing.Literal['struct', 'list', 'map'] | None:
            ...

    @typing.final
    class ScalarFunction(google.protobuf.message.Message):
        """A scalar function call."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        FUNCTION_REFERENCE_FIELD_NUMBER: builtins.int
        ARGUMENTS_FIELD_NUMBER: builtins.int
        OPTIONS_FIELD_NUMBER: builtins.int
        OUTPUT_TYPE_FIELD_NUMBER: builtins.int
        ARGS_FIELD_NUMBER: builtins.int
        function_reference: builtins.int
        'Points to a function_anchor defined in this plan, which must refer\n        to a scalar function in the associated YAML file. Required; avoid\n        using anchor/reference zero.\n        '

        @property
        def arguments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionArgument]:
            """The arguments to be bound to the function. This must have exactly the
            number of arguments specified in the function definition, and the
            argument types must also match exactly:

             - Value arguments must be bound using FunctionArgument.value, and
               the expression in that must yield a value of a type that a function
               overload is defined for.
             - Type arguments must be bound using FunctionArgument.type.
             - Enum arguments must be bound using FunctionArgument.enum
               followed by Enum.specified, with a string that case-insensitively
               matches one of the allowed options.
            """

        @property
        def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionOption]:
            """Options to specify behavior for corner cases, or leave behavior
            unspecified if the consumer does not need specific behavior in these
            cases.
            """

        @property
        def output_type(self) -> proto.type_pb2.Type:
            """Must be set to the return type of the function, exactly as derived
            using the declaration in the extension.
            """

        @property
        def args(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """Deprecated; use arguments instead."""

        def __init__(self, *, function_reference: builtins.int=..., arguments: collections.abc.Iterable[global___FunctionArgument] | None=..., options: collections.abc.Iterable[global___FunctionOption] | None=..., output_type: proto.type_pb2.Type | None=..., args: collections.abc.Iterable[global___Expression] | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['output_type', b'output_type']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['args', b'args', 'arguments', b'arguments', 'function_reference', b'function_reference', 'options', b'options', 'output_type', b'output_type']) -> None:
            ...

    @typing.final
    class WindowFunction(google.protobuf.message.Message):
        """A window function call."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _BoundsType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _BoundsTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Expression.WindowFunction._BoundsType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            BOUNDS_TYPE_UNSPECIFIED: Expression.WindowFunction._BoundsType.ValueType
            BOUNDS_TYPE_ROWS: Expression.WindowFunction._BoundsType.ValueType
            'The lower and upper bound specify how many rows before and after the current row\n            the window should extend.\n            '
            BOUNDS_TYPE_RANGE: Expression.WindowFunction._BoundsType.ValueType
            'The lower and upper bound describe a range of values.  The window should include all rows\n            where the value of the ordering column is greater than or equal to (current_value - lower bound)\n            and less than or equal to (current_value + upper bound).  This bounds type is only valid if there\n            is a single ordering column.\n            '

        class BoundsType(_BoundsType, metaclass=_BoundsTypeEnumTypeWrapper):
            ...
        BOUNDS_TYPE_UNSPECIFIED: Expression.WindowFunction.BoundsType.ValueType
        BOUNDS_TYPE_ROWS: Expression.WindowFunction.BoundsType.ValueType
        'The lower and upper bound specify how many rows before and after the current row\n        the window should extend.\n        '
        BOUNDS_TYPE_RANGE: Expression.WindowFunction.BoundsType.ValueType
        'The lower and upper bound describe a range of values.  The window should include all rows\n        where the value of the ordering column is greater than or equal to (current_value - lower bound)\n        and less than or equal to (current_value + upper bound).  This bounds type is only valid if there\n        is a single ordering column.\n        '

        @typing.final
        class Bound(google.protobuf.message.Message):
            """Defines one of the two boundaries for the window of a window function."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            @typing.final
            class Preceding(google.protobuf.message.Message):
                """Defines that the bound extends this far back from the current record."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                OFFSET_FIELD_NUMBER: builtins.int
                offset: builtins.int
                'A strictly positive integer specifying the number of records that\n                the window extends back from the current record. Required. Use\n                CurrentRow for offset zero and Following for negative offsets.\n                '

                def __init__(self, *, offset: builtins.int=...) -> None:
                    ...

                def ClearField(self, field_name: typing.Literal['offset', b'offset']) -> None:
                    ...

            @typing.final
            class Following(google.protobuf.message.Message):
                """Defines that the bound extends this far ahead of the current record."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                OFFSET_FIELD_NUMBER: builtins.int
                offset: builtins.int
                'A strictly positive integer specifying the number of records that\n                the window extends ahead of the current record. Required. Use\n                CurrentRow for offset zero and Preceding for negative offsets.\n                '

                def __init__(self, *, offset: builtins.int=...) -> None:
                    ...

                def ClearField(self, field_name: typing.Literal['offset', b'offset']) -> None:
                    ...

            @typing.final
            class CurrentRow(google.protobuf.message.Message):
                """Defines that the bound extends to or from the current record."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor

                def __init__(self) -> None:
                    ...

            @typing.final
            class Unbounded(google.protobuf.message.Message):
                """Defines an "unbounded bound": for lower bounds this means the start
                of the partition, and for upper bounds this means the end of the
                partition.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor

                def __init__(self) -> None:
                    ...
            PRECEDING_FIELD_NUMBER: builtins.int
            FOLLOWING_FIELD_NUMBER: builtins.int
            CURRENT_ROW_FIELD_NUMBER: builtins.int
            UNBOUNDED_FIELD_NUMBER: builtins.int

            @property
            def preceding(self) -> global___Expression.WindowFunction.Bound.Preceding:
                """The bound extends some number of records behind the current record."""

            @property
            def following(self) -> global___Expression.WindowFunction.Bound.Following:
                """The bound extends some number of records ahead of the current
                record.
                """

            @property
            def current_row(self) -> global___Expression.WindowFunction.Bound.CurrentRow:
                """The bound extends to the current record."""

            @property
            def unbounded(self) -> global___Expression.WindowFunction.Bound.Unbounded:
                """The bound extends to the start of the partition or the end of the
                partition, depending on whether this represents the upper or lower
                bound.
                """

            def __init__(self, *, preceding: global___Expression.WindowFunction.Bound.Preceding | None=..., following: global___Expression.WindowFunction.Bound.Following | None=..., current_row: global___Expression.WindowFunction.Bound.CurrentRow | None=..., unbounded: global___Expression.WindowFunction.Bound.Unbounded | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['current_row', b'current_row', 'following', b'following', 'kind', b'kind', 'preceding', b'preceding', 'unbounded', b'unbounded']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['current_row', b'current_row', 'following', b'following', 'kind', b'kind', 'preceding', b'preceding', 'unbounded', b'unbounded']) -> None:
                ...

            def WhichOneof(self, oneof_group: typing.Literal['kind', b'kind']) -> typing.Literal['preceding', 'following', 'current_row', 'unbounded'] | None:
                ...
        FUNCTION_REFERENCE_FIELD_NUMBER: builtins.int
        ARGUMENTS_FIELD_NUMBER: builtins.int
        OPTIONS_FIELD_NUMBER: builtins.int
        OUTPUT_TYPE_FIELD_NUMBER: builtins.int
        PHASE_FIELD_NUMBER: builtins.int
        SORTS_FIELD_NUMBER: builtins.int
        INVOCATION_FIELD_NUMBER: builtins.int
        PARTITIONS_FIELD_NUMBER: builtins.int
        BOUNDS_TYPE_FIELD_NUMBER: builtins.int
        LOWER_BOUND_FIELD_NUMBER: builtins.int
        UPPER_BOUND_FIELD_NUMBER: builtins.int
        ARGS_FIELD_NUMBER: builtins.int
        function_reference: builtins.int
        'Points to a function_anchor defined in this plan. The function must be:\n         - a window function\n         - an aggregate function\n\n        An aggregate function referenced here should be treated as a window\n        function with Window Type STREAMING\n\n        Required; 0 is considered to be a valid anchor/reference.\n        '
        phase: global___AggregationPhase.ValueType
        'Describes which part of the window function to perform within the\n        context of distributed algorithms. Required. Must be set to\n        INITIAL_TO_RESULT for window functions that are not decomposable.\n        '
        invocation: global___AggregateFunction.AggregationInvocation.ValueType
        'Specifies whether equivalent records are merged before being aggregated.\n        Optional, defaults to AGGREGATION_INVOCATION_ALL.\n        '
        bounds_type: global___Expression.WindowFunction.BoundsType.ValueType
        'Defines the bounds type: ROWS, RANGE'

        @property
        def arguments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionArgument]:
            """The arguments to be bound to the function. This must have exactly the
            number of arguments specified in the function definition, and the
            argument types must also match exactly:

             - Value arguments must be bound using FunctionArgument.value, and
               the expression in that must yield a value of a type that a function
               overload is defined for.
             - Type arguments must be bound using FunctionArgument.type, and a
               function overload must be defined for that type.
             - Enum arguments must be bound using FunctionArgument.enum
               followed by Enum.specified, with a string that case-insensitively
               matches one of the allowed options.
            """

        @property
        def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionOption]:
            """Options to specify behavior for corner cases, or leave behavior
            unspecified if the consumer does not need specific behavior in these
            cases.
            """

        @property
        def output_type(self) -> proto.type_pb2.Type:
            """Must be set to the return type of the function, exactly as derived
            using the declaration in the extension.
            """

        @property
        def sorts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SortField]:
            """If specified, the records that are part of the window defined by
            upper_bound and lower_bound are ordered according to this list
            before they are aggregated. The first sort field has the highest
            priority; only if a sort field determines two records to be equivalent
            is the next field queried. This field is optional, and is only allowed
            if the window function is defined to support sorting.
            """

        @property
        def partitions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """When one or more partition expressions are specified, two records are
            considered to be in the same partition if and only if these expressions
            yield an equal record of values for both. When computing the window
            function, only the subset of records within the bounds that are also in
            the same partition as the current record are aggregated.
            """

        @property
        def lower_bound(self) -> global___Expression.WindowFunction.Bound:
            """Defines the record relative to the current record from which the window
            extends. The bound is inclusive. If the lower bound indexes a record
            greater than the upper bound, TODO (null range/no records passed?
            wrapping around as if lower/upper were swapped? error? null?).
            Optional; defaults to the start of the partition.
            """

        @property
        def upper_bound(self) -> global___Expression.WindowFunction.Bound:
            """Defines the record relative to the current record up to which the window
            extends. The bound is inclusive. If the upper bound indexes a record
            less than the lower bound, TODO (null range/no records passed?
            wrapping around as if lower/upper were swapped? error? null?).
            Optional; defaults to the end of the partition.
            """

        @property
        def args(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """Deprecated; use arguments instead."""

        def __init__(self, *, function_reference: builtins.int=..., arguments: collections.abc.Iterable[global___FunctionArgument] | None=..., options: collections.abc.Iterable[global___FunctionOption] | None=..., output_type: proto.type_pb2.Type | None=..., phase: global___AggregationPhase.ValueType=..., sorts: collections.abc.Iterable[global___SortField] | None=..., invocation: global___AggregateFunction.AggregationInvocation.ValueType=..., partitions: collections.abc.Iterable[global___Expression] | None=..., bounds_type: global___Expression.WindowFunction.BoundsType.ValueType=..., lower_bound: global___Expression.WindowFunction.Bound | None=..., upper_bound: global___Expression.WindowFunction.Bound | None=..., args: collections.abc.Iterable[global___Expression] | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['lower_bound', b'lower_bound', 'output_type', b'output_type', 'upper_bound', b'upper_bound']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['args', b'args', 'arguments', b'arguments', 'bounds_type', b'bounds_type', 'function_reference', b'function_reference', 'invocation', b'invocation', 'lower_bound', b'lower_bound', 'options', b'options', 'output_type', b'output_type', 'partitions', b'partitions', 'phase', b'phase', 'sorts', b'sorts', 'upper_bound', b'upper_bound']) -> None:
            ...

    @typing.final
    class IfThen(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class IfClause(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            IF_FIELD_NUMBER: builtins.int
            THEN_FIELD_NUMBER: builtins.int

            @property
            def then(self) -> global___Expression:
                ...

            def __init__(self, *, then: global___Expression | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['if', b'if', 'then', b'then']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['if', b'if', 'then', b'then']) -> None:
                ...
        IFS_FIELD_NUMBER: builtins.int
        ELSE_FIELD_NUMBER: builtins.int

        @property
        def ifs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.IfThen.IfClause]:
            """A list of one or more IfClauses"""

        def __init__(self, *, ifs: collections.abc.Iterable[global___Expression.IfThen.IfClause] | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['else', b'else']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['else', b'else', 'ifs', b'ifs']) -> None:
            ...

    @typing.final
    class Cast(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _FailureBehavior:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _FailureBehaviorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Expression.Cast._FailureBehavior.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            FAILURE_BEHAVIOR_UNSPECIFIED: Expression.Cast._FailureBehavior.ValueType
            FAILURE_BEHAVIOR_RETURN_NULL: Expression.Cast._FailureBehavior.ValueType
            FAILURE_BEHAVIOR_THROW_EXCEPTION: Expression.Cast._FailureBehavior.ValueType

        class FailureBehavior(_FailureBehavior, metaclass=_FailureBehaviorEnumTypeWrapper):
            ...
        FAILURE_BEHAVIOR_UNSPECIFIED: Expression.Cast.FailureBehavior.ValueType
        FAILURE_BEHAVIOR_RETURN_NULL: Expression.Cast.FailureBehavior.ValueType
        FAILURE_BEHAVIOR_THROW_EXCEPTION: Expression.Cast.FailureBehavior.ValueType
        TYPE_FIELD_NUMBER: builtins.int
        INPUT_FIELD_NUMBER: builtins.int
        FAILURE_BEHAVIOR_FIELD_NUMBER: builtins.int
        failure_behavior: global___Expression.Cast.FailureBehavior.ValueType

        @property
        def type(self) -> proto.type_pb2.Type:
            ...

        @property
        def input(self) -> global___Expression:
            ...

        def __init__(self, *, type: proto.type_pb2.Type | None=..., input: global___Expression | None=..., failure_behavior: global___Expression.Cast.FailureBehavior.ValueType=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['input', b'input', 'type', b'type']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['failure_behavior', b'failure_behavior', 'input', b'input', 'type', b'type']) -> None:
            ...

    @typing.final
    class SwitchExpression(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class IfValue(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            IF_FIELD_NUMBER: builtins.int
            THEN_FIELD_NUMBER: builtins.int

            @property
            def then(self) -> global___Expression:
                ...

            def __init__(self, *, then: global___Expression | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['if', b'if', 'then', b'then']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['if', b'if', 'then', b'then']) -> None:
                ...
        MATCH_FIELD_NUMBER: builtins.int
        IFS_FIELD_NUMBER: builtins.int
        ELSE_FIELD_NUMBER: builtins.int

        @property
        def match(self) -> global___Expression:
            ...

        @property
        def ifs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.SwitchExpression.IfValue]:
            ...

        def __init__(self, *, match: global___Expression | None=..., ifs: collections.abc.Iterable[global___Expression.SwitchExpression.IfValue] | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['else', b'else', 'match', b'match']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['else', b'else', 'ifs', b'ifs', 'match', b'match']) -> None:
            ...

    @typing.final
    class SingularOrList(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        VALUE_FIELD_NUMBER: builtins.int
        OPTIONS_FIELD_NUMBER: builtins.int

        @property
        def value(self) -> global___Expression:
            ...

        @property
        def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            ...

        def __init__(self, *, value: global___Expression | None=..., options: collections.abc.Iterable[global___Expression] | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['value', b'value']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['options', b'options', 'value', b'value']) -> None:
            ...

    @typing.final
    class MultiOrList(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class Record(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            FIELDS_FIELD_NUMBER: builtins.int

            @property
            def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
                ...

            def __init__(self, *, fields: collections.abc.Iterable[global___Expression] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['fields', b'fields']) -> None:
                ...
        VALUE_FIELD_NUMBER: builtins.int
        OPTIONS_FIELD_NUMBER: builtins.int

        @property
        def value(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            ...

        @property
        def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.MultiOrList.Record]:
            ...

        def __init__(self, *, value: collections.abc.Iterable[global___Expression] | None=..., options: collections.abc.Iterable[global___Expression.MultiOrList.Record] | None=...) -> None:
            ...

        def ClearField(self, field_name: typing.Literal['options', b'options', 'value', b'value']) -> None:
            ...

    @typing.final
    class EmbeddedFunction(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class PythonPickleFunction(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            FUNCTION_FIELD_NUMBER: builtins.int
            PREREQUISITE_FIELD_NUMBER: builtins.int
            function: builtins.bytes

            @property
            def prerequisite(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
                ...

            def __init__(self, *, function: builtins.bytes=..., prerequisite: collections.abc.Iterable[builtins.str] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['function', b'function', 'prerequisite', b'prerequisite']) -> None:
                ...

        @typing.final
        class WebAssemblyFunction(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            SCRIPT_FIELD_NUMBER: builtins.int
            PREREQUISITE_FIELD_NUMBER: builtins.int
            script: builtins.bytes

            @property
            def prerequisite(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
                ...

            def __init__(self, *, script: builtins.bytes=..., prerequisite: collections.abc.Iterable[builtins.str] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['prerequisite', b'prerequisite', 'script', b'script']) -> None:
                ...
        ARGUMENTS_FIELD_NUMBER: builtins.int
        OUTPUT_TYPE_FIELD_NUMBER: builtins.int
        PYTHON_PICKLE_FUNCTION_FIELD_NUMBER: builtins.int
        WEB_ASSEMBLY_FUNCTION_FIELD_NUMBER: builtins.int

        @property
        def arguments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            ...

        @property
        def output_type(self) -> proto.type_pb2.Type:
            ...

        @property
        def python_pickle_function(self) -> global___Expression.EmbeddedFunction.PythonPickleFunction:
            ...

        @property
        def web_assembly_function(self) -> global___Expression.EmbeddedFunction.WebAssemblyFunction:
            ...

        def __init__(self, *, arguments: collections.abc.Iterable[global___Expression] | None=..., output_type: proto.type_pb2.Type | None=..., python_pickle_function: global___Expression.EmbeddedFunction.PythonPickleFunction | None=..., web_assembly_function: global___Expression.EmbeddedFunction.WebAssemblyFunction | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['kind', b'kind', 'output_type', b'output_type', 'python_pickle_function', b'python_pickle_function', 'web_assembly_function', b'web_assembly_function']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['arguments', b'arguments', 'kind', b'kind', 'output_type', b'output_type', 'python_pickle_function', b'python_pickle_function', 'web_assembly_function', b'web_assembly_function']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['kind', b'kind']) -> typing.Literal['python_pickle_function', 'web_assembly_function'] | None:
            ...

    @typing.final
    class ReferenceSegment(google.protobuf.message.Message):
        """A way to reference the inner property of a complex record. Can reference
        either a map key by literal, a struct field by the ordinal position of
        the desired field or a particular element in an array. Supports
        expressions that would roughly translate to something similar to:
        a.b[2].c['my_map_key'].x where a,b,c and x are struct field references
        (ordinalized in the internal representation here), [2] is a list offset
        and ['my_map_key'] is a reference into a map field.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class MapKey(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            MAP_KEY_FIELD_NUMBER: builtins.int
            CHILD_FIELD_NUMBER: builtins.int

            @property
            def map_key(self) -> global___Expression.Literal:
                """literal based reference to specific possible value in map."""

            @property
            def child(self) -> global___Expression.ReferenceSegment:
                """Optional child segment"""

            def __init__(self, *, map_key: global___Expression.Literal | None=..., child: global___Expression.ReferenceSegment | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['child', b'child', 'map_key', b'map_key']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['child', b'child', 'map_key', b'map_key']) -> None:
                ...

        @typing.final
        class StructField(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            FIELD_FIELD_NUMBER: builtins.int
            CHILD_FIELD_NUMBER: builtins.int
            field: builtins.int
            'zero-indexed ordinal position of field in struct'

            @property
            def child(self) -> global___Expression.ReferenceSegment:
                """Optional child segment"""

            def __init__(self, *, field: builtins.int=..., child: global___Expression.ReferenceSegment | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['child', b'child']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['child', b'child', 'field', b'field']) -> None:
                ...

        @typing.final
        class ListElement(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            OFFSET_FIELD_NUMBER: builtins.int
            CHILD_FIELD_NUMBER: builtins.int
            offset: builtins.int
            'zero-indexed ordinal position of element in list'

            @property
            def child(self) -> global___Expression.ReferenceSegment:
                """Optional child segment"""

            def __init__(self, *, offset: builtins.int=..., child: global___Expression.ReferenceSegment | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['child', b'child']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['child', b'child', 'offset', b'offset']) -> None:
                ...
        MAP_KEY_FIELD_NUMBER: builtins.int
        STRUCT_FIELD_FIELD_NUMBER: builtins.int
        LIST_ELEMENT_FIELD_NUMBER: builtins.int

        @property
        def map_key(self) -> global___Expression.ReferenceSegment.MapKey:
            ...

        @property
        def struct_field(self) -> global___Expression.ReferenceSegment.StructField:
            ...

        @property
        def list_element(self) -> global___Expression.ReferenceSegment.ListElement:
            ...

        def __init__(self, *, map_key: global___Expression.ReferenceSegment.MapKey | None=..., struct_field: global___Expression.ReferenceSegment.StructField | None=..., list_element: global___Expression.ReferenceSegment.ListElement | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['list_element', b'list_element', 'map_key', b'map_key', 'reference_type', b'reference_type', 'struct_field', b'struct_field']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['list_element', b'list_element', 'map_key', b'map_key', 'reference_type', b'reference_type', 'struct_field', b'struct_field']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['reference_type', b'reference_type']) -> typing.Literal['map_key', 'struct_field', 'list_element'] | None:
            ...

    @typing.final
    class MaskExpression(google.protobuf.message.Message):
        """A reference that takes an existing subtype and selectively removes fields
        from it. For example, one might initially have an inner struct with 100
        fields but a a particular operation only needs to interact with only 2 of
        those 100 fields. In this situation, one would use a mask expression to
        eliminate the 98 fields that are not relevant to the rest of the operation
        pipeline.

        Note that this does not fundamentally alter the structure of data beyond
        the elimination of unnecessary elements.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class Select(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            STRUCT_FIELD_NUMBER: builtins.int
            LIST_FIELD_NUMBER: builtins.int
            MAP_FIELD_NUMBER: builtins.int

            @property
            def struct(self) -> global___Expression.MaskExpression.StructSelect:
                ...

            @property
            def list(self) -> global___Expression.MaskExpression.ListSelect:
                ...

            @property
            def map(self) -> global___Expression.MaskExpression.MapSelect:
                ...

            def __init__(self, *, struct: global___Expression.MaskExpression.StructSelect | None=..., list: global___Expression.MaskExpression.ListSelect | None=..., map: global___Expression.MaskExpression.MapSelect | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['list', b'list', 'map', b'map', 'struct', b'struct', 'type', b'type']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['list', b'list', 'map', b'map', 'struct', b'struct', 'type', b'type']) -> None:
                ...

            def WhichOneof(self, oneof_group: typing.Literal['type', b'type']) -> typing.Literal['struct', 'list', 'map'] | None:
                ...

        @typing.final
        class StructSelect(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            STRUCT_ITEMS_FIELD_NUMBER: builtins.int

            @property
            def struct_items(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.MaskExpression.StructItem]:
                ...

            def __init__(self, *, struct_items: collections.abc.Iterable[global___Expression.MaskExpression.StructItem] | None=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['struct_items', b'struct_items']) -> None:
                ...

        @typing.final
        class StructItem(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            FIELD_FIELD_NUMBER: builtins.int
            CHILD_FIELD_NUMBER: builtins.int
            field: builtins.int

            @property
            def child(self) -> global___Expression.MaskExpression.Select:
                ...

            def __init__(self, *, field: builtins.int=..., child: global___Expression.MaskExpression.Select | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['child', b'child']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['child', b'child', 'field', b'field']) -> None:
                ...

        @typing.final
        class ListSelect(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            @typing.final
            class ListSelectItem(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor

                @typing.final
                class ListElement(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor
                    FIELD_FIELD_NUMBER: builtins.int
                    field: builtins.int

                    def __init__(self, *, field: builtins.int=...) -> None:
                        ...

                    def ClearField(self, field_name: typing.Literal['field', b'field']) -> None:
                        ...

                @typing.final
                class ListSlice(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor
                    START_FIELD_NUMBER: builtins.int
                    END_FIELD_NUMBER: builtins.int
                    start: builtins.int
                    end: builtins.int

                    def __init__(self, *, start: builtins.int=..., end: builtins.int=...) -> None:
                        ...

                    def ClearField(self, field_name: typing.Literal['end', b'end', 'start', b'start']) -> None:
                        ...
                ITEM_FIELD_NUMBER: builtins.int
                SLICE_FIELD_NUMBER: builtins.int

                @property
                def item(self) -> global___Expression.MaskExpression.ListSelect.ListSelectItem.ListElement:
                    ...

                @property
                def slice(self) -> global___Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice:
                    ...

                def __init__(self, *, item: global___Expression.MaskExpression.ListSelect.ListSelectItem.ListElement | None=..., slice: global___Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice | None=...) -> None:
                    ...

                def HasField(self, field_name: typing.Literal['item', b'item', 'slice', b'slice', 'type', b'type']) -> builtins.bool:
                    ...

                def ClearField(self, field_name: typing.Literal['item', b'item', 'slice', b'slice', 'type', b'type']) -> None:
                    ...

                def WhichOneof(self, oneof_group: typing.Literal['type', b'type']) -> typing.Literal['item', 'slice'] | None:
                    ...
            SELECTION_FIELD_NUMBER: builtins.int
            CHILD_FIELD_NUMBER: builtins.int

            @property
            def selection(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression.MaskExpression.ListSelect.ListSelectItem]:
                ...

            @property
            def child(self) -> global___Expression.MaskExpression.Select:
                ...

            def __init__(self, *, selection: collections.abc.Iterable[global___Expression.MaskExpression.ListSelect.ListSelectItem] | None=..., child: global___Expression.MaskExpression.Select | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['child', b'child']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['child', b'child', 'selection', b'selection']) -> None:
                ...

        @typing.final
        class MapSelect(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            @typing.final
            class MapKey(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                MAP_KEY_FIELD_NUMBER: builtins.int
                map_key: builtins.str

                def __init__(self, *, map_key: builtins.str=...) -> None:
                    ...

                def ClearField(self, field_name: typing.Literal['map_key', b'map_key']) -> None:
                    ...

            @typing.final
            class MapKeyExpression(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                MAP_KEY_EXPRESSION_FIELD_NUMBER: builtins.int
                map_key_expression: builtins.str

                def __init__(self, *, map_key_expression: builtins.str=...) -> None:
                    ...

                def ClearField(self, field_name: typing.Literal['map_key_expression', b'map_key_expression']) -> None:
                    ...
            KEY_FIELD_NUMBER: builtins.int
            EXPRESSION_FIELD_NUMBER: builtins.int
            CHILD_FIELD_NUMBER: builtins.int

            @property
            def key(self) -> global___Expression.MaskExpression.MapSelect.MapKey:
                ...

            @property
            def expression(self) -> global___Expression.MaskExpression.MapSelect.MapKeyExpression:
                ...

            @property
            def child(self) -> global___Expression.MaskExpression.Select:
                ...

            def __init__(self, *, key: global___Expression.MaskExpression.MapSelect.MapKey | None=..., expression: global___Expression.MaskExpression.MapSelect.MapKeyExpression | None=..., child: global___Expression.MaskExpression.Select | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['child', b'child', 'expression', b'expression', 'key', b'key', 'select', b'select']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['child', b'child', 'expression', b'expression', 'key', b'key', 'select', b'select']) -> None:
                ...

            def WhichOneof(self, oneof_group: typing.Literal['select', b'select']) -> typing.Literal['key', 'expression'] | None:
                ...
        SELECT_FIELD_NUMBER: builtins.int
        MAINTAIN_SINGULAR_STRUCT_FIELD_NUMBER: builtins.int
        maintain_singular_struct: builtins.bool

        @property
        def select(self) -> global___Expression.MaskExpression.StructSelect:
            ...

        def __init__(self, *, select: global___Expression.MaskExpression.StructSelect | None=..., maintain_singular_struct: builtins.bool=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['select', b'select']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['maintain_singular_struct', b'maintain_singular_struct', 'select', b'select']) -> None:
            ...

    @typing.final
    class FieldReference(google.protobuf.message.Message):
        """A reference to an inner part of a complex object. Can reference reference a
        single element or a masked version of elements
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class RootReference(google.protobuf.message.Message):
            """Singleton that expresses this FieldReference is rooted off the root
            incoming record type
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            def __init__(self) -> None:
                ...

        @typing.final
        class OuterReference(google.protobuf.message.Message):
            """A root reference for the outer relation's subquery"""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            STEPS_OUT_FIELD_NUMBER: builtins.int
            steps_out: builtins.int
            "number of subquery boundaries to traverse up for this field's reference\n\n            This value must be >= 1\n            "

            def __init__(self, *, steps_out: builtins.int=...) -> None:
                ...

            def ClearField(self, field_name: typing.Literal['steps_out', b'steps_out']) -> None:
                ...
        DIRECT_REFERENCE_FIELD_NUMBER: builtins.int
        MASKED_REFERENCE_FIELD_NUMBER: builtins.int
        EXPRESSION_FIELD_NUMBER: builtins.int
        ROOT_REFERENCE_FIELD_NUMBER: builtins.int
        OUTER_REFERENCE_FIELD_NUMBER: builtins.int

        @property
        def direct_reference(self) -> global___Expression.ReferenceSegment:
            ...

        @property
        def masked_reference(self) -> global___Expression.MaskExpression:
            ...

        @property
        def expression(self) -> global___Expression:
            ...

        @property
        def root_reference(self) -> global___Expression.FieldReference.RootReference:
            ...

        @property
        def outer_reference(self) -> global___Expression.FieldReference.OuterReference:
            ...

        def __init__(self, *, direct_reference: global___Expression.ReferenceSegment | None=..., masked_reference: global___Expression.MaskExpression | None=..., expression: global___Expression | None=..., root_reference: global___Expression.FieldReference.RootReference | None=..., outer_reference: global___Expression.FieldReference.OuterReference | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['direct_reference', b'direct_reference', 'expression', b'expression', 'masked_reference', b'masked_reference', 'outer_reference', b'outer_reference', 'reference_type', b'reference_type', 'root_reference', b'root_reference', 'root_type', b'root_type']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['direct_reference', b'direct_reference', 'expression', b'expression', 'masked_reference', b'masked_reference', 'outer_reference', b'outer_reference', 'reference_type', b'reference_type', 'root_reference', b'root_reference', 'root_type', b'root_type']) -> None:
            ...

        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal['reference_type', b'reference_type']) -> typing.Literal['direct_reference', 'masked_reference'] | None:
            ...

        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal['root_type', b'root_type']) -> typing.Literal['expression', 'root_reference', 'outer_reference'] | None:
            ...

    @typing.final
    class Subquery(google.protobuf.message.Message):
        """Subquery relation expression"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class Scalar(google.protobuf.message.Message):
            """A subquery with one row and one column. This is often an aggregate
            though not required to be.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            INPUT_FIELD_NUMBER: builtins.int

            @property
            def input(self) -> global___Rel:
                ...

            def __init__(self, *, input: global___Rel | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['input', b'input']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['input', b'input']) -> None:
                ...

        @typing.final
        class InPredicate(google.protobuf.message.Message):
            """Predicate checking that the left expression is contained in the right
            subquery

            Examples:

            x IN (SELECT * FROM t)
            (x, y) IN (SELECT a, b FROM t)
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            NEEDLES_FIELD_NUMBER: builtins.int
            HAYSTACK_FIELD_NUMBER: builtins.int

            @property
            def needles(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
                ...

            @property
            def haystack(self) -> global___Rel:
                ...

            def __init__(self, *, needles: collections.abc.Iterable[global___Expression] | None=..., haystack: global___Rel | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['haystack', b'haystack']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['haystack', b'haystack', 'needles', b'needles']) -> None:
                ...

        @typing.final
        class SetPredicate(google.protobuf.message.Message):
            """A predicate over a set of rows in the form of a subquery
            EXISTS and UNIQUE are common SQL forms of this operation.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            class _PredicateOp:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType

            class _PredicateOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Expression.Subquery.SetPredicate._PredicateOp.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
                PREDICATE_OP_UNSPECIFIED: Expression.Subquery.SetPredicate._PredicateOp.ValueType
                PREDICATE_OP_EXISTS: Expression.Subquery.SetPredicate._PredicateOp.ValueType
                PREDICATE_OP_UNIQUE: Expression.Subquery.SetPredicate._PredicateOp.ValueType

            class PredicateOp(_PredicateOp, metaclass=_PredicateOpEnumTypeWrapper):
                ...
            PREDICATE_OP_UNSPECIFIED: Expression.Subquery.SetPredicate.PredicateOp.ValueType
            PREDICATE_OP_EXISTS: Expression.Subquery.SetPredicate.PredicateOp.ValueType
            PREDICATE_OP_UNIQUE: Expression.Subquery.SetPredicate.PredicateOp.ValueType
            PREDICATE_OP_FIELD_NUMBER: builtins.int
            TUPLES_FIELD_NUMBER: builtins.int
            predicate_op: global___Expression.Subquery.SetPredicate.PredicateOp.ValueType
            'TODO: should allow expressions'

            @property
            def tuples(self) -> global___Rel:
                ...

            def __init__(self, *, predicate_op: global___Expression.Subquery.SetPredicate.PredicateOp.ValueType=..., tuples: global___Rel | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['tuples', b'tuples']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['predicate_op', b'predicate_op', 'tuples', b'tuples']) -> None:
                ...

        @typing.final
        class SetComparison(google.protobuf.message.Message):
            """A subquery comparison using ANY or ALL.
            Examples:

            SELECT *
            FROM t1
            WHERE x < ANY(SELECT y from t2)
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            class _ComparisonOp:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType

            class _ComparisonOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Expression.Subquery.SetComparison._ComparisonOp.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
                COMPARISON_OP_UNSPECIFIED: Expression.Subquery.SetComparison._ComparisonOp.ValueType
                COMPARISON_OP_EQ: Expression.Subquery.SetComparison._ComparisonOp.ValueType
                COMPARISON_OP_NE: Expression.Subquery.SetComparison._ComparisonOp.ValueType
                COMPARISON_OP_LT: Expression.Subquery.SetComparison._ComparisonOp.ValueType
                COMPARISON_OP_GT: Expression.Subquery.SetComparison._ComparisonOp.ValueType
                COMPARISON_OP_LE: Expression.Subquery.SetComparison._ComparisonOp.ValueType
                COMPARISON_OP_GE: Expression.Subquery.SetComparison._ComparisonOp.ValueType

            class ComparisonOp(_ComparisonOp, metaclass=_ComparisonOpEnumTypeWrapper):
                ...
            COMPARISON_OP_UNSPECIFIED: Expression.Subquery.SetComparison.ComparisonOp.ValueType
            COMPARISON_OP_EQ: Expression.Subquery.SetComparison.ComparisonOp.ValueType
            COMPARISON_OP_NE: Expression.Subquery.SetComparison.ComparisonOp.ValueType
            COMPARISON_OP_LT: Expression.Subquery.SetComparison.ComparisonOp.ValueType
            COMPARISON_OP_GT: Expression.Subquery.SetComparison.ComparisonOp.ValueType
            COMPARISON_OP_LE: Expression.Subquery.SetComparison.ComparisonOp.ValueType
            COMPARISON_OP_GE: Expression.Subquery.SetComparison.ComparisonOp.ValueType

            class _ReductionOp:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType

            class _ReductionOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Expression.Subquery.SetComparison._ReductionOp.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
                REDUCTION_OP_UNSPECIFIED: Expression.Subquery.SetComparison._ReductionOp.ValueType
                REDUCTION_OP_ANY: Expression.Subquery.SetComparison._ReductionOp.ValueType
                REDUCTION_OP_ALL: Expression.Subquery.SetComparison._ReductionOp.ValueType

            class ReductionOp(_ReductionOp, metaclass=_ReductionOpEnumTypeWrapper):
                ...
            REDUCTION_OP_UNSPECIFIED: Expression.Subquery.SetComparison.ReductionOp.ValueType
            REDUCTION_OP_ANY: Expression.Subquery.SetComparison.ReductionOp.ValueType
            REDUCTION_OP_ALL: Expression.Subquery.SetComparison.ReductionOp.ValueType
            REDUCTION_OP_FIELD_NUMBER: builtins.int
            COMPARISON_OP_FIELD_NUMBER: builtins.int
            LEFT_FIELD_NUMBER: builtins.int
            RIGHT_FIELD_NUMBER: builtins.int
            reduction_op: global___Expression.Subquery.SetComparison.ReductionOp.ValueType
            'ANY or ALL'
            comparison_op: global___Expression.Subquery.SetComparison.ComparisonOp.ValueType
            'A comparison operator'

            @property
            def left(self) -> global___Expression:
                """left side of the expression"""

            @property
            def right(self) -> global___Rel:
                """right side of the expression"""

            def __init__(self, *, reduction_op: global___Expression.Subquery.SetComparison.ReductionOp.ValueType=..., comparison_op: global___Expression.Subquery.SetComparison.ComparisonOp.ValueType=..., left: global___Expression | None=..., right: global___Rel | None=...) -> None:
                ...

            def HasField(self, field_name: typing.Literal['left', b'left', 'right', b'right']) -> builtins.bool:
                ...

            def ClearField(self, field_name: typing.Literal['comparison_op', b'comparison_op', 'left', b'left', 'reduction_op', b'reduction_op', 'right', b'right']) -> None:
                ...
        SCALAR_FIELD_NUMBER: builtins.int
        IN_PREDICATE_FIELD_NUMBER: builtins.int
        SET_PREDICATE_FIELD_NUMBER: builtins.int
        SET_COMPARISON_FIELD_NUMBER: builtins.int

        @property
        def scalar(self) -> global___Expression.Subquery.Scalar:
            """Scalar subquery"""

        @property
        def in_predicate(self) -> global___Expression.Subquery.InPredicate:
            """x IN y predicate"""

        @property
        def set_predicate(self) -> global___Expression.Subquery.SetPredicate:
            """EXISTS/UNIQUE predicate"""

        @property
        def set_comparison(self) -> global___Expression.Subquery.SetComparison:
            """ANY/ALL predicate"""

        def __init__(self, *, scalar: global___Expression.Subquery.Scalar | None=..., in_predicate: global___Expression.Subquery.InPredicate | None=..., set_predicate: global___Expression.Subquery.SetPredicate | None=..., set_comparison: global___Expression.Subquery.SetComparison | None=...) -> None:
            ...

        def HasField(self, field_name: typing.Literal['in_predicate', b'in_predicate', 'scalar', b'scalar', 'set_comparison', b'set_comparison', 'set_predicate', b'set_predicate', 'subquery_type', b'subquery_type']) -> builtins.bool:
            ...

        def ClearField(self, field_name: typing.Literal['in_predicate', b'in_predicate', 'scalar', b'scalar', 'set_comparison', b'set_comparison', 'set_predicate', b'set_predicate', 'subquery_type', b'subquery_type']) -> None:
            ...

        def WhichOneof(self, oneof_group: typing.Literal['subquery_type', b'subquery_type']) -> typing.Literal['scalar', 'in_predicate', 'set_predicate', 'set_comparison'] | None:
            ...
    LITERAL_FIELD_NUMBER: builtins.int
    SELECTION_FIELD_NUMBER: builtins.int
    SCALAR_FUNCTION_FIELD_NUMBER: builtins.int
    WINDOW_FUNCTION_FIELD_NUMBER: builtins.int
    IF_THEN_FIELD_NUMBER: builtins.int
    SWITCH_EXPRESSION_FIELD_NUMBER: builtins.int
    SINGULAR_OR_LIST_FIELD_NUMBER: builtins.int
    MULTI_OR_LIST_FIELD_NUMBER: builtins.int
    CAST_FIELD_NUMBER: builtins.int
    SUBQUERY_FIELD_NUMBER: builtins.int
    NESTED_FIELD_NUMBER: builtins.int
    DYNAMIC_PARAMETER_FIELD_NUMBER: builtins.int
    ENUM_FIELD_NUMBER: builtins.int

    @property
    def literal(self) -> global___Expression.Literal:
        ...

    @property
    def selection(self) -> global___Expression.FieldReference:
        ...

    @property
    def scalar_function(self) -> global___Expression.ScalarFunction:
        ...

    @property
    def window_function(self) -> global___Expression.WindowFunction:
        ...

    @property
    def if_then(self) -> global___Expression.IfThen:
        ...

    @property
    def switch_expression(self) -> global___Expression.SwitchExpression:
        ...

    @property
    def singular_or_list(self) -> global___Expression.SingularOrList:
        ...

    @property
    def multi_or_list(self) -> global___Expression.MultiOrList:
        ...

    @property
    def cast(self) -> global___Expression.Cast:
        ...

    @property
    def subquery(self) -> global___Expression.Subquery:
        ...

    @property
    def nested(self) -> global___Expression.Nested:
        ...

    @property
    def dynamic_parameter(self) -> global___DynamicParameter:
        ...

    @property
    def enum(self) -> global___Expression.Enum:
        """deprecated: enum literals are only sensible in the context of
        function arguments, for which FunctionArgument should now be
        used
        """

    def __init__(self, *, literal: global___Expression.Literal | None=..., selection: global___Expression.FieldReference | None=..., scalar_function: global___Expression.ScalarFunction | None=..., window_function: global___Expression.WindowFunction | None=..., if_then: global___Expression.IfThen | None=..., switch_expression: global___Expression.SwitchExpression | None=..., singular_or_list: global___Expression.SingularOrList | None=..., multi_or_list: global___Expression.MultiOrList | None=..., cast: global___Expression.Cast | None=..., subquery: global___Expression.Subquery | None=..., nested: global___Expression.Nested | None=..., dynamic_parameter: global___DynamicParameter | None=..., enum: global___Expression.Enum | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['cast', b'cast', 'dynamic_parameter', b'dynamic_parameter', 'enum', b'enum', 'if_then', b'if_then', 'literal', b'literal', 'multi_or_list', b'multi_or_list', 'nested', b'nested', 'rex_type', b'rex_type', 'scalar_function', b'scalar_function', 'selection', b'selection', 'singular_or_list', b'singular_or_list', 'subquery', b'subquery', 'switch_expression', b'switch_expression', 'window_function', b'window_function']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['cast', b'cast', 'dynamic_parameter', b'dynamic_parameter', 'enum', b'enum', 'if_then', b'if_then', 'literal', b'literal', 'multi_or_list', b'multi_or_list', 'nested', b'nested', 'rex_type', b'rex_type', 'scalar_function', b'scalar_function', 'selection', b'selection', 'singular_or_list', b'singular_or_list', 'subquery', b'subquery', 'switch_expression', b'switch_expression', 'window_function', b'window_function']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['rex_type', b'rex_type']) -> typing.Literal['literal', 'selection', 'scalar_function', 'window_function', 'if_then', 'switch_expression', 'singular_or_list', 'multi_or_list', 'cast', 'subquery', 'nested', 'dynamic_parameter', 'enum'] | None:
        ...
global___Expression = Expression

@typing.final
class DynamicParameter(google.protobuf.message.Message):
    """Expression that represents a dynamic parameter.
    Dynamic parameters are identified by a surrogate key within a plan.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TYPE_FIELD_NUMBER: builtins.int
    PARAMETER_REFERENCE_FIELD_NUMBER: builtins.int
    parameter_reference: builtins.int
    'The surrogate key used within a plan to reference a specific parameter binding.'

    @property
    def type(self) -> proto.type_pb2.Type:
        """The type of the dynamic parameter."""

    def __init__(self, *, type: proto.type_pb2.Type | None=..., parameter_reference: builtins.int=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['type', b'type']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['parameter_reference', b'parameter_reference', 'type', b'type']) -> None:
        ...
global___DynamicParameter = DynamicParameter

@typing.final
class SortField(google.protobuf.message.Message):
    """The description of a field to sort on (including the direction of sorting and null semantics)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SortDirection:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SortDirectionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SortField._SortDirection.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SORT_DIRECTION_UNSPECIFIED: SortField._SortDirection.ValueType
        SORT_DIRECTION_ASC_NULLS_FIRST: SortField._SortDirection.ValueType
        SORT_DIRECTION_ASC_NULLS_LAST: SortField._SortDirection.ValueType
        SORT_DIRECTION_DESC_NULLS_FIRST: SortField._SortDirection.ValueType
        SORT_DIRECTION_DESC_NULLS_LAST: SortField._SortDirection.ValueType
        SORT_DIRECTION_CLUSTERED: SortField._SortDirection.ValueType

    class SortDirection(_SortDirection, metaclass=_SortDirectionEnumTypeWrapper):
        ...
    SORT_DIRECTION_UNSPECIFIED: SortField.SortDirection.ValueType
    SORT_DIRECTION_ASC_NULLS_FIRST: SortField.SortDirection.ValueType
    SORT_DIRECTION_ASC_NULLS_LAST: SortField.SortDirection.ValueType
    SORT_DIRECTION_DESC_NULLS_FIRST: SortField.SortDirection.ValueType
    SORT_DIRECTION_DESC_NULLS_LAST: SortField.SortDirection.ValueType
    SORT_DIRECTION_CLUSTERED: SortField.SortDirection.ValueType
    EXPR_FIELD_NUMBER: builtins.int
    DIRECTION_FIELD_NUMBER: builtins.int
    COMPARISON_FUNCTION_REFERENCE_FIELD_NUMBER: builtins.int
    direction: global___SortField.SortDirection.ValueType
    comparison_function_reference: builtins.int

    @property
    def expr(self) -> global___Expression:
        ...

    def __init__(self, *, expr: global___Expression | None=..., direction: global___SortField.SortDirection.ValueType=..., comparison_function_reference: builtins.int=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['comparison_function_reference', b'comparison_function_reference', 'direction', b'direction', 'expr', b'expr', 'sort_kind', b'sort_kind']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['comparison_function_reference', b'comparison_function_reference', 'direction', b'direction', 'expr', b'expr', 'sort_kind', b'sort_kind']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['sort_kind', b'sort_kind']) -> typing.Literal['direction', 'comparison_function_reference'] | None:
        ...
global___SortField = SortField

@typing.final
class AggregateFunction(google.protobuf.message.Message):
    """An aggregate function."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _AggregationInvocation:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _AggregationInvocationEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[AggregateFunction._AggregationInvocation.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        AGGREGATION_INVOCATION_UNSPECIFIED: AggregateFunction._AggregationInvocation.ValueType
        'This default value implies AGGREGATION_INVOCATION_ALL.'
        AGGREGATION_INVOCATION_ALL: AggregateFunction._AggregationInvocation.ValueType
        'Use all values in the aggregation calculation.'
        AGGREGATION_INVOCATION_DISTINCT: AggregateFunction._AggregationInvocation.ValueType
        'Use only distinct values in the aggregation calculation.'

    class AggregationInvocation(_AggregationInvocation, metaclass=_AggregationInvocationEnumTypeWrapper):
        """Method in which equivalent records are merged before being aggregated."""
    AGGREGATION_INVOCATION_UNSPECIFIED: AggregateFunction.AggregationInvocation.ValueType
    'This default value implies AGGREGATION_INVOCATION_ALL.'
    AGGREGATION_INVOCATION_ALL: AggregateFunction.AggregationInvocation.ValueType
    'Use all values in the aggregation calculation.'
    AGGREGATION_INVOCATION_DISTINCT: AggregateFunction.AggregationInvocation.ValueType
    'Use only distinct values in the aggregation calculation.'
    FUNCTION_REFERENCE_FIELD_NUMBER: builtins.int
    ARGUMENTS_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    OUTPUT_TYPE_FIELD_NUMBER: builtins.int
    PHASE_FIELD_NUMBER: builtins.int
    SORTS_FIELD_NUMBER: builtins.int
    INVOCATION_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    function_reference: builtins.int
    'Points to a function_anchor defined in this plan, which must refer\n    to an aggregate function in the associated YAML file. Required; 0 is\n    considered to be a valid anchor/reference.\n    '
    phase: global___AggregationPhase.ValueType
    'Describes which part of the aggregation to perform within the context of\n    distributed algorithms. Required. Must be set to INITIAL_TO_RESULT for\n    aggregate functions that are not decomposable.\n    '
    invocation: global___AggregateFunction.AggregationInvocation.ValueType
    'Specifies whether equivalent records are merged before being aggregated.\n    Optional, defaults to AGGREGATION_INVOCATION_ALL.\n    '

    @property
    def arguments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionArgument]:
        """The arguments to be bound to the function. This must have exactly the
        number of arguments specified in the function definition, and the
        argument types must also match exactly:

         - Value arguments must be bound using FunctionArgument.value, and
           the expression in that must yield a value of a type that a function
           overload is defined for.
         - Type arguments must be bound using FunctionArgument.type, and a
           function overload must be defined for that type.
         - Enum arguments must be bound using FunctionArgument.enum
           followed by Enum.specified, with a string that case-insensitively
           matches one of the allowed options.
         - Optional enum arguments must be bound using FunctionArgument.enum
           followed by either Enum.specified or Enum.unspecified. If specified,
           the string must case-insensitively match one of the allowed options.
        """

    @property
    def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionOption]:
        """Options to specify behavior for corner cases, or leave behavior
        unspecified if the consumer does not need specific behavior in these
        cases.
        """

    @property
    def output_type(self) -> proto.type_pb2.Type:
        """Must be set to the return type of the function, exactly as derived
        using the declaration in the extension.
        """

    @property
    def sorts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SortField]:
        """If specified, the aggregated records are ordered according to this list
        before they are aggregated. The first sort field has the highest
        priority; only if a sort field determines two records to be equivalent is
        the next field queried. This field is optional.
        """

    @property
    def args(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        """deprecated; use arguments instead"""

    def __init__(self, *, function_reference: builtins.int=..., arguments: collections.abc.Iterable[global___FunctionArgument] | None=..., options: collections.abc.Iterable[global___FunctionOption] | None=..., output_type: proto.type_pb2.Type | None=..., phase: global___AggregationPhase.ValueType=..., sorts: collections.abc.Iterable[global___SortField] | None=..., invocation: global___AggregateFunction.AggregationInvocation.ValueType=..., args: collections.abc.Iterable[global___Expression] | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['output_type', b'output_type']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['args', b'args', 'arguments', b'arguments', 'function_reference', b'function_reference', 'invocation', b'invocation', 'options', b'options', 'output_type', b'output_type', 'phase', b'phase', 'sorts', b'sorts']) -> None:
        ...
global___AggregateFunction = AggregateFunction

@typing.final
class ReferenceRel(google.protobuf.message.Message):
    """This rel is used  to create references,
    in case we refer to a RelRoot field names will be ignored
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SUBTREE_ORDINAL_FIELD_NUMBER: builtins.int
    subtree_ordinal: builtins.int

    def __init__(self, *, subtree_ordinal: builtins.int=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['subtree_ordinal', b'subtree_ordinal']) -> None:
        ...
global___ReferenceRel = ReferenceRel