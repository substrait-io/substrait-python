"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
SPDX-License-Identifier: Apache-2.0"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import proto.algebra_pb2
import proto.extensions.extensions_pb2
import proto.type_pb2
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class PlanRel(google.protobuf.message.Message):
    """Either a relation or root relation"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REL_FIELD_NUMBER: builtins.int
    ROOT_FIELD_NUMBER: builtins.int
    @property
    def rel(self) -> proto.algebra_pb2.Rel:
        """Any relation (used for references and CTEs)"""

    @property
    def root(self) -> proto.algebra_pb2.RelRoot:
        """The root of a relation tree"""

    def __init__(
        self,
        *,
        rel: proto.algebra_pb2.Rel | None = ...,
        root: proto.algebra_pb2.RelRoot | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["rel", b"rel", "rel_type", b"rel_type", "root", b"root"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["rel", b"rel", "rel_type", b"rel_type", "root", b"root"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["rel_type", b"rel_type"]) -> typing.Literal["rel", "root"] | None: ...

global___PlanRel = PlanRel

@typing.final
class Plan(google.protobuf.message.Message):
    """Describe a set of operations to complete.
    For compactness sake, identifiers are normalized at the plan level.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    EXTENSION_URIS_FIELD_NUMBER: builtins.int
    EXTENSION_URNS_FIELD_NUMBER: builtins.int
    EXTENSIONS_FIELD_NUMBER: builtins.int
    RELATIONS_FIELD_NUMBER: builtins.int
    ADVANCED_EXTENSIONS_FIELD_NUMBER: builtins.int
    EXPECTED_TYPE_URLS_FIELD_NUMBER: builtins.int
    PARAMETER_BINDINGS_FIELD_NUMBER: builtins.int
    TYPE_ALIASES_FIELD_NUMBER: builtins.int
    @property
    def version(self) -> global___Version:
        """Substrait version of the plan. Optional up to 0.17.0, required for later
        versions.
        """

    @property
    def extension_uris(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[proto.extensions.extensions_pb2.SimpleExtensionURI]:
        """a list of yaml specifications this plan may depend on
        this is now deprecated and extension_urns should be used instead.
        """

    @property
    def extension_urns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[proto.extensions.extensions_pb2.SimpleExtensionURN]:
        """a list of extension URNs this plan may depend on"""

    @property
    def extensions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[proto.extensions.extensions_pb2.SimpleExtensionDeclaration]:
        """a list of extensions this plan may depend on"""

    @property
    def relations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PlanRel]:
        """one or more relation trees that are associated with this plan."""

    @property
    def advanced_extensions(self) -> proto.extensions.extensions_pb2.AdvancedExtension:
        """additional extensions associated with this plan."""

    @property
    def expected_type_urls(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A list of com.google.Any entities that this plan may use. Can be used to
        warn if some embedded message types are unknown. Note that this list may
        include message types that are ignorable (optimizations) or that are
        unused. In many cases, a consumer may be able to work with a plan even if
        one or more message types defined here are unknown.
        """

    @property
    def parameter_bindings(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DynamicParameterBinding]:
        """An optional list of bindings for dynamic parameters used in this plan.
        Each binding maps a parameter_anchor to its corresponding runtime value.
        """

    @property
    def type_aliases(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[proto.type_pb2.TypeAlias]:
        """An optional list of type aliases. Types can be specified here once, and
        then referenced within the plan using the TypeAliasReference type. This
        feature is intended to assist with the usability of parameterized types,
        which require that all parameters be specified when they are declared.
        This can bloat plans with redundant redeclarations, especially if the
        parameterized types being declared have many parameters (e.g., struct with
        many fields, nested parameterized types, string as a type parameter).
        """

    def __init__(
        self,
        *,
        version: global___Version | None = ...,
        extension_uris: collections.abc.Iterable[proto.extensions.extensions_pb2.SimpleExtensionURI] | None = ...,
        extension_urns: collections.abc.Iterable[proto.extensions.extensions_pb2.SimpleExtensionURN] | None = ...,
        extensions: collections.abc.Iterable[proto.extensions.extensions_pb2.SimpleExtensionDeclaration] | None = ...,
        relations: collections.abc.Iterable[global___PlanRel] | None = ...,
        advanced_extensions: proto.extensions.extensions_pb2.AdvancedExtension | None = ...,
        expected_type_urls: collections.abc.Iterable[builtins.str] | None = ...,
        parameter_bindings: collections.abc.Iterable[global___DynamicParameterBinding] | None = ...,
        type_aliases: collections.abc.Iterable[proto.type_pb2.TypeAlias] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["advanced_extensions", b"advanced_extensions", "version", b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["advanced_extensions", b"advanced_extensions", "expected_type_urls", b"expected_type_urls", "extension_uris", b"extension_uris", "extension_urns", b"extension_urns", "extensions", b"extensions", "parameter_bindings", b"parameter_bindings", "relations", b"relations", "type_aliases", b"type_aliases", "version", b"version"]) -> None: ...

global___Plan = Plan

@typing.final
class PlanVersion(google.protobuf.message.Message):
    """This message type can be used to deserialize only the version of a Substrait
    Plan message. This prevents deserialization errors when there were breaking
    changes between the Substrait version of the tool that produced the plan and
    the Substrait version used to deserialize it, such that a consumer can emit
    a more helpful error message in this case.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    @property
    def version(self) -> global___Version: ...
    def __init__(
        self,
        *,
        version: global___Version | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["version", b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["version", b"version"]) -> None: ...

global___PlanVersion = PlanVersion

@typing.final
class Version(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAJOR_NUMBER_FIELD_NUMBER: builtins.int
    MINOR_NUMBER_FIELD_NUMBER: builtins.int
    PATCH_NUMBER_FIELD_NUMBER: builtins.int
    GIT_HASH_FIELD_NUMBER: builtins.int
    PRODUCER_FIELD_NUMBER: builtins.int
    major_number: builtins.int
    """Substrait version number."""
    minor_number: builtins.int
    patch_number: builtins.int
    git_hash: builtins.str
    """If a particular version of Substrait is used that does not correspond to
    a version number exactly (for example when using an unofficial fork or
    using a version that is not yet released or is between versions), set this
    to the full git hash of the utilized commit of
    https://github.com/substrait-io/substrait (or fork thereof), represented
    using a lowercase hex ASCII string 40 characters in length. The version
    number above should be set to the most recent version tag in the history
    of that commit.
    """
    producer: builtins.str
    """Identifying information for the producer that created this plan. Under
    ideal circumstances, consumers should not need this information. However,
    it is foreseen that consumers may need to work around bugs in particular
    producers in practice, and therefore may need to know which producer
    created the plan.
    """
    def __init__(
        self,
        *,
        major_number: builtins.int = ...,
        minor_number: builtins.int = ...,
        patch_number: builtins.int = ...,
        git_hash: builtins.str = ...,
        producer: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["git_hash", b"git_hash", "major_number", b"major_number", "minor_number", b"minor_number", "patch_number", b"patch_number", "producer", b"producer"]) -> None: ...

global___Version = Version

@typing.final
class DynamicParameterBinding(google.protobuf.message.Message):
    """Represents a binding for a dynamic parameter."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMETER_ANCHOR_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    parameter_anchor: builtins.int
    """The parameter anchor that identifies the dynamic parameter reference."""
    @property
    def value(self) -> proto.algebra_pb2.Expression.Literal:
        """The literal value assigned to the parameter at runtime.
        The type of the literal needs to match the type of the corresponding
        DynamicParameter expression in the plan.
        """

    def __init__(
        self,
        *,
        parameter_anchor: builtins.int = ...,
        value: proto.algebra_pb2.Expression.Literal | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["parameter_anchor", b"parameter_anchor", "value", b"value"]) -> None: ...

global___DynamicParameterBinding = DynamicParameterBinding
